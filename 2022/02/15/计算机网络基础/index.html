<!DOCTYPE html>
<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Noto Serif SC:300,300italic,400,400italic,700,700italic|Lobster Two:300,300italic,400,400italic,700,700italic|EB Garamond:300,300italic,400,400italic,700,700italic|Source Code Pro:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"zodical416.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":false,"style":"mac"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="城市就躲在光明的背后">
<meta property="og:type" content="article">
<meta property="og:title" content="计算机网络基础">
<meta property="og:url" content="https://zodical416.github.io/2022/02/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/index.html">
<meta property="og:site_name" content="Zodiacal">
<meta property="og:description" content="城市就躲在光明的背后">
<meta property="og:locale">
<meta property="og:image" content="https://raw.githubusercontent.com/zodical416/picto/master/20220215151852.png">
<meta property="og:image" content="https://raw.githubusercontent.com/zodical416/picto/master/20220215154503.png">
<meta property="og:image" content="https://raw.githubusercontent.com/zodical416/picto/master/20220215154714.png">
<meta property="og:image" content="https://raw.githubusercontent.com/zodical416/picto/master/20220215155907.png">
<meta property="og:image" content="https://raw.githubusercontent.com/zodical416/picto/master/20220215162846.png">
<meta property="og:image" content="https://raw.githubusercontent.com/zodical416/picto/master/20220215180509.png">
<meta property="og:image" content="https://raw.githubusercontent.com/zodical416/picto/master/20220215222710.png">
<meta property="og:image" content="https://raw.githubusercontent.com/zodical416/picto/master/20220215230219.png">
<meta property="og:image" content="https://raw.githubusercontent.com/zodical416/picto/master/20220215231218.png">
<meta property="og:image" content="https://raw.githubusercontent.com/zodical416/picto/master/20220215231307.png">
<meta property="article:published_time" content="2022-02-15T15:24:07.616Z">
<meta property="article:modified_time" content="2022-08-15T12:36:30.741Z">
<meta property="article:author" content="Zodiacal">
<meta property="article:tag" content="计算机基础">
<meta property="article:tag" content="八股">
<meta property="article:tag" content="计算机网络">
<meta property="article:tag" content="TCP&#x2F;IP">
<meta property="article:tag" content="Http">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://raw.githubusercontent.com/zodical416/picto/master/20220215151852.png">

<link rel="canonical" href="https://zodical416.github.io/2022/02/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-Hans'
  };
</script>

  <title>计算机网络基础 | Zodiacal</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Zodiacal</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://zodical416.github.io/2022/02/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zodiacal">
      <meta itemprop="description" content="引出魔鬼的一种试炼">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zodiacal">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          计算机网络基础
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-02-15 23:24:07" itemprop="dateCreated datePublished" datetime="2022-02-15T23:24:07+08:00">2022-02-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-08-15 20:36:30" itemprop="dateModified" datetime="2022-08-15T20:36:30+08:00">2022-08-15</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index"><span itemprop="name">计算机基础</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>19k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>18 分钟</span>
            </span>
            <div class="post-description">城市就躲在光明的背后</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="计算机网络的分层参考模型"><a href="#计算机网络的分层参考模型" class="headerlink" title="计算机网络的分层参考模型"></a>计算机网络的分层参考模型</h1><p><img src="https://raw.githubusercontent.com/zodical416/picto/master/20220215151852.png"></p>
<p>自上而下介绍各层的作用：</p>
<h2 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h2><p>应用层 (application-layer）的任务是通过应用进程间的交互来完成特定网络应用。应用层协议定义的是应用进程（进程：主机中正在运行的程序）间的通信和交互的规则。对于不同的网络应用需要不同的应用层协议。在互联网中应用层协议很多，如域名系统 DNS，支持万维网应用的 HTTP 协议，支持电子邮件的 SMTP 协议等等。我们把应用层交互的数据单元称为报文。</p>
<blockquote>
<p>域名系统：可以将域名和 IP 地址相互映射的一个分布式数据库</p>
<p>HTTP 协议：所有的 WWW（万维网） 文件都必须遵守这个标准。设计 HTTP 最初的目的是为了提供一种发布和接收 HTML 页面的方法。</p>
</blockquote>
<h2 id="运输层"><a href="#运输层" class="headerlink" title="运输层"></a>运输层</h2><p>运输层(transport layer)的主要任务就是负责向两台主机进程之间的通信提供通用的数据传输服务。应用进程利用该服务传送应用层报文。“通用的”是指并不针对某一个特定的网络应用，而是多种应用可以使用同一个运输层服务。</p>
<h2 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h2><p>在计算机网络中进行通信的两个计算机之间可能会经过很多个数据链路，也可能还要经过很多通信子网。网络层的任务就是选择合适的网间路由和交换结点， 确保数据及时传送。在发送数据时，网络层把运输层产生的报文段或用户数据报封装成分组和包进行传送。在 TCP/IP 体系结构中，由于网络层使用 <strong>IP 协议</strong>，因此分组也叫 <strong>IP 数据报</strong> ，简称 <strong>数据报</strong>。</p>
<h2 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h2><p>数据链路层(data link layer)通常简称为链路层。两台主机之间的数据传输，总是在一段一段的链路上传送的，这就需要使用专门的链路层的协议。 在两个相邻节点之间传送数据时，数据链路层将网络层交下来的 IP 数据报组装成帧，在两个相邻节点间的链路上传送帧。每一帧包括数据和必要的控制信息（如同步信息，地址信息，差错控制等）。</p>
<h2 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h2><p>在物理层上所传送的数据单位是比特。</p>
<p>物理层(physical layer)的作用是实现相邻计算机节点之间比特流的透明传送，尽可能屏蔽掉具体传输介质和物理设备的差异， 使其上面的数据链路层不必考虑网络的具体传输介质是什么。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><img src="https://raw.githubusercontent.com/zodical416/picto/master/20220215154503.png"></p>
<h1 id="TCP-三次握手和四次挥手"><a href="#TCP-三次握手和四次挥手" class="headerlink" title="TCP 三次握手和四次挥手"></a>TCP 三次握手和四次挥手</h1><h2 id="TCP-的三次握手"><a href="#TCP-的三次握手" class="headerlink" title="TCP 的三次握手"></a>TCP 的三次握手</h2><p>为了准确地把数据送到目标处，TCP 协议采用了三次握手机制，其基本流程如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/zodical416/picto/master/20220215154714.png"></p>
<ul>
<li>客户端发送带有 SYN 标志的数据包到服务端——一次握手</li>
<li>服务端发送带有 SYN/ACK 标志的数据包给客户端——二次握手</li>
<li>客户端发送带有 ACK 标志的数据包给服务端——三次握手</li>
</ul>
<p>详细流程如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/zodical416/picto/master/20220215155907.png"></p>
<p>最开始的时候客户端和服务器都是处于CLOSED状态。主动打开连接的为客户端，被动打开连接的是服务器。</p>
<ul>
<li>TCP服务器进程先创建 <strong>传输控制块TCB</strong>，时刻准备接受客户进程的连接请求，此时服务器就进入了LISTEN（监听）状态；</li>
<li>TCP客户进程也是先创建传输控制块TCB，然后向服务器发出连接请求报文。报文首部中的同步位 SYN=1，同时选择一个初始序列号 seq=x，此时，TCP客户端进程进入了 SYN-SENT（同步已发送状态）状态。<strong>TCP规定，SYN报文段（SYN=1的报文段）不能携带数据，但需要消耗掉一个序号。</strong></li>
<li>TCP服务器收到请求报文后，如果同意连接，则发出确认报文。确认报文中应该置 ACK=1，SYN=1，确认号是 ack=x+1，同时也要为自己初始化一个序列号 seq=y，此时，TCP服务器进程进入了SYN-RCVD（同步收到）状态。<strong>这个报文也不能携带数据，但是同样要消耗一个序号。</strong></li>
<li>TCP客户进程收到确认后，还要向服务器给出确认。确认报文的ACK=1，ack=y+1，自己的序列号seq=x+1，此时，TCP连接建立，客户端进入ESTABLISHED（已建立连接）状态。<strong>TCP规定，ACK报文段可以携带数据，但是如果不携带数据则不消耗序号。</strong></li>
<li>当服务器收到客户端的确认后也进入ESTABLISHED状态，此后双方就可以开始通信了。</li>
</ul>
<h3 id="为什么要三次握手"><a href="#为什么要三次握手" class="headerlink" title="为什么要三次握手"></a>为什么要三次握手</h3><p>三次握手的目的是建立可靠的通信信道，使通信双方确认自己与对方的发送与接收是正常的。</p>
<p>第一次握手：客户端什么都不能确认；服务端确认了对方发送正常，自己接收正常</p>
<p>第二次握手：客户端确认了：自己发送、接收正常，对方发送、接收正常；服务端确认了：对方发送正常，自己接收正常</p>
<p>第三次握手：客户端确认了：自己发送、接收正常，对方发送、接收正常；服务端确认了：自己发送、接收正常，对方发送、接收正常</p>
<h3 id="为什么TCP客户端最后还要发送一次确认呢？"><a href="#为什么TCP客户端最后还要发送一次确认呢？" class="headerlink" title="为什么TCP客户端最后还要发送一次确认呢？"></a>为什么TCP客户端最后还要发送一次确认呢？</h3><p>主要防止已经失效的连接请求报文突然又传送到了服务器，从而产生错误。</p>
<p>假如使用两次握手连接，假设这样的一个场景：<strong>客户端发送了第一个请求连接并且没有丢失，只是在网络结点中滞留的时间太长了。</strong> 由于TCP的客户端迟迟没有收到确认报文，以为服务器没有收到，此时重新向服务器发送这条报文，此后客户端和服务器经过两次握手完成连接，传输数据，然后关闭连接，完成了一次正常的通信。</p>
<p>然而此时，此前滞留的那一次请求连接的网络通畅了，到达了服务器，这个报文本该是失效的，但是，两次握手的机制将会让客户端和服务器再次建立连接，这将导致不必要的错误和资源的浪费。</p>
<p>如果采用的是三次握手，就算是那一次失效的报文传送过来了，服务端接受到了那条失效报文并且回复了确认报文，但是客户端不会再次发出确认。由于服务器收不到确认，就知道客户端并没有请求连接。</p>
<h3 id="第-2-次握手传回了-ACK，为什么还要传回-SYN？"><a href="#第-2-次握手传回了-ACK，为什么还要传回-SYN？" class="headerlink" title="第 2 次握手传回了 ACK，为什么还要传回 SYN？"></a>第 2 次握手传回了 ACK，为什么还要传回 SYN？</h3><p>传回的 ACK 是为了向客户端确认服务端已经收到了客户端所发送的信号，表明从客户端到服务端的通信是正常的。而 SYN 则是为了建立并确认从服务端到客户端的通信。</p>
<blockquote>
<p>SYN 同步序列编号：是 TCP/IP 建立连接时使用的握手信号。在客户机和服务器之间建立正常的 TCP 网络连接时，客户机首先发出一个 SYN 消息，服务器使用 SYN-ACK 应答表示接收到了这个消息，最后客户机再以 ACK(Acknowledgement）消息响应。这样在客户机和服务器之间才能建立起可靠的 TCP 连接，数据才可以在客户机和服务器之间传递。</p>
</blockquote>
<h2 id="TCP-的四次挥手"><a href="#TCP-的四次挥手" class="headerlink" title="TCP 的四次挥手"></a>TCP 的四次挥手</h2><p>数据传输完毕后，通信双方都可释放连接。最开始的时候，客户端和服务器都是处于 ESTABLISHED 状态，然后客户端主动关闭，服务器被动关闭。</p>
<ul>
<li>客户端进程发出连接释放报文，并且停止发送数据。FIN=1，其序列号为seq=u（等于前面已经传送过来的数据的最后一个字节的序号加1），此时，客户端进入FIN-WAIT-1（终止等待1）状态。<strong>TCP规定，FIN报文段即使不携带数据，也要消耗一个序号。</strong></li>
<li>服务器收到连接释放报文，发出确认报文。ACK=1，ack=u+1，并且带上自己的序列号seq=v，此时，服务端就进入了CLOSE-WAIT（关闭等待）状态。TCP服务器通知高层的应用进程，客户端向服务器方向的通信链路就释放了，这时候处于半关闭状态，即：客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受。<strong>这个状态还要持续一段时间，也就是整个CLOSE-WAIT状态持续的时间。</strong></li>
<li>客户端收到服务器的确认请求后，此时，客户端就进入FIN-WAIT-2（终止等待2）状态，等待服务器发送连接释放报文（<strong>在这之前还需要接受服务器发送的最后的数据</strong>）</li>
<li>服务器将最后的数据发送完毕后，就向客户端发送连接释放报文。FIN=1，ack=u+1，由于在半关闭状态，服务器很可能又发送了一些数据，假定此时的序列号为seq=w，此时，服务器就进入了LAST-ACK（最后确认）状态，等待客户端的确认。</li>
<li>客户端收到服务器的连接释放报文后，必须发出确认，ACK=1，ack=w+1，而自己的序列号是seq=u+1，此时，客户端就进入了TIME-WAIT（时间等待）状态。<strong>注意此时TCP连接还没有释放，必须经过 2 ∗ MSL（最长报文段寿命）的时间后，当客户端撤销相应的TCB后，才进入CLOSED状态。</strong></li>
<li>服务器只要收到了客户端发出的确认，立即进入CLOSED状态。同样，撤销TCB后，就结束了这次的TCP连接。<strong>可以看到，服务器结束TCP连接的时间要比客户端早一些。</strong></li>
</ul>
<p><img src="https://raw.githubusercontent.com/zodical416/picto/master/20220215162846.png"></p>
<h3 id="为什么客户端最后还要等待2MSL？"><a href="#为什么客户端最后还要等待2MSL？" class="headerlink" title="为什么客户端最后还要等待2MSL？"></a>为什么客户端最后还要等待2MSL？</h3><ul>
<li>第一，保证客户端发送的最后一个ACK报文能够到达服务器，因为这个ACK报文可能丢失。站在服务器的角度看来，我已经发送了FIN+ACK报文请求断开了，客户端还没有给我回应，应该是我发送的请求断开报文它没有收到，于是服务器又会重新发送一次。而客户端就能在这个2MSL时间段内收到这个重传的报文，接着给出回应报文，并且会重启2MSL计时器。</li>
<li>第二，防止类似与“三次握手”中提到了的“已经失效的连接请求报文段”出现在本连接中。客户端发送完最后一个确认报文后，在这个2MSL时间中，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失。这样新的连接中不会出现旧连接的请求报文。</li>
</ul>
<h3 id="为什么建立连接是三次握手，关闭连接确是四次挥手呢？"><a href="#为什么建立连接是三次握手，关闭连接确是四次挥手呢？" class="headerlink" title="为什么建立连接是三次握手，关闭连接确是四次挥手呢？"></a>为什么建立连接是三次握手，关闭连接确是四次挥手呢？</h3><p>建立连接的时候， 服务器在LISTEN状态下，收到建立连接请求的SYN报文后，把ACK和SYN放在一个报文里发送给客户端。</p>
<p>而关闭连接时，服务器收到对方的FIN报文时，仅仅表示对方不再发送数据了但是还能接收数据，而自己也未必已经将全部数据都发送给对方了，所以己方可以立即关闭，也可以发送一些数据给对方后，再发送FIN报文给对方来表示同意现在关闭连接。因此，己方ACK和FIN一般都会分开发送，从而导致多了一次。</p>
<h3 id="如果已经建立了连接，但是客户端突然出现故障了怎么办"><a href="#如果已经建立了连接，但是客户端突然出现故障了怎么办" class="headerlink" title="如果已经建立了连接，但是客户端突然出现故障了怎么办"></a>如果已经建立了连接，但是客户端突然出现故障了怎么办</h3><p>TCP还设有一个保活计时器，显然，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75秒发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。</p>
<h1 id="TCP-和-UDP-的区别"><a href="#TCP-和-UDP-的区别" class="headerlink" title="TCP 和 UDP 的区别"></a>TCP 和 UDP 的区别</h1><p>UDP 在传送数据之前不需要先建立连接，远地主机在收到 UDP 报文后，不需要给出任何确认。虽然 UDP 不提供可靠交付，但在某些情况下 UDP 却是一种最有效的工作方式（一般用于即时通信）。</p>
<p>TCP 提供面向连接的服务。在传送数据之前必须先建立连接，数据传送结束后要释放连接。TCP 不提供广播或多播服务。由于 TCP 要提供可靠的，面向连接的传输服务（TCP 的可靠体现在 TCP 在传递数据之前，会有三次握手来建立连接，而且在数据传递时，有确认、窗口、重传、拥塞控制机制，在数据传完后，还会断开连接用来节约系统资源），这难以避免增加了许多开销，如确认，流量控制，计时器以及连接管理等。这不仅使协议数据单元的首部增大很多，还要占用许多处理机资源。TCP 一般用于文件传输、发送和接收邮件、远程登录等场景。</p>
<h1 id="TCP-协议如何保证可靠传输"><a href="#TCP-协议如何保证可靠传输" class="headerlink" title="TCP 协议如何保证可靠传输"></a>TCP 协议如何保证可靠传输</h1><ol>
<li>应用数据被分割成 TCP 认为最适合发送的数据块。</li>
<li>TCP 给发送的每一个包进行编号，接收方对数据包进行排序，把有序数据传送给应用层。</li>
<li><strong>校验和：</strong> TCP 将保持它首部和数据的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP 将丢弃这个报文段和不确认收到此报文段。</li>
<li>TCP 的接收端会丢弃重复的数据。</li>
<li><strong>流量控制：</strong> TCP 连接的每一方都有固定大小的缓冲空间，TCP 的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。TCP 使用的流量控制协议是可变大小的滑动窗口协议。（也就是所谓的，TCP 利用滑动窗口实现流量控制）</li>
<li><strong>拥塞控制：</strong> 当网络拥塞时，减少数据的发送。</li>
<li><strong>ARQ 协议：</strong> 每发完一个分组就停止发送，等待对方确认。在收到确认后再发下一个分组。</li>
<li><strong>超时重传：</strong> 当 TCP 发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。</li>
</ol>
<h2 id="ARQ-协议"><a href="#ARQ-协议" class="headerlink" title="ARQ 协议"></a>ARQ 协议</h2><p>即自动请求重传协议，是 OSI 模型中数据链路层和传输层的错误纠正协议之一。它通过使用确认和超时这两个机制，在不可靠服务的基础上实现可靠的信息传输。如果发送方在发送后一段时间之内没有收到确认帧，它通常会重新发送。ARQ 包括停止等待 ARQ 协议和连续 ARQ 协议。</p>
<h3 id="停止等待-ARQ-协议"><a href="#停止等待-ARQ-协议" class="headerlink" title="停止等待 ARQ 协议"></a>停止等待 ARQ 协议</h3><p>停止等待协议的基本原理就是每发完一个分组就停止发送，等待对方确认（回复 ACK）。如果过了一段时间（超时时间后），还是没有收到 ACK 确认，说明没有发送成功，需要重新发送，直到收到确认后再发下一个分组。</p>
<p>在停止等待协议中，若接收方收到重复分组，就丢弃该分组，但同时还要发送确认。</p>
<p>该方法的主要优点就是简单，但是缺点也非常明显，由于等待时间长，会使得信道利用率低。</p>
<h3 id="连续-ARQ-协议"><a href="#连续-ARQ-协议" class="headerlink" title="连续 ARQ 协议"></a>连续 ARQ 协议</h3><p>连续 ARQ 协议可提高信道利用率。发送方维持一个发送窗口，凡位于发送窗口内的分组可以连续发送出去，而不需要等待对方确认。接收方一般采用累积确认，对按序到达的最后一个分组发送确认，表明到这个分组为止的所有分组都已经正确收到了。</p>
<p>该方法与停止等待协议相比，提高了信道利用率，并且容易实现。然而缺点就是不能向发送方反映出接收方已经正确收到的所有分组的信息。</p>
<blockquote>
<p>例如，发送方发送了 5 条 消息，中间第三条丢失（3 号），这时接收方只能对前两个发送确认。发送方无法知道后三个分组的下落，而只好把后三个全部重传一次。这也叫 Go-Back-N（回退 N），表示需要退回来重传已经发送过的 N 个消息。</p>
</blockquote>
<h3 id="重传类型"><a href="#重传类型" class="headerlink" title="重传类型"></a>重传类型</h3><p><strong>出现差错情况（超时重传）:</strong> 停止等待协议中超时重传是指只要超过一段时间仍然没有收到确认，就重传前面发送过的分组（认为刚才发送过的分组丢失了）。因此每发送完一个分组需要设置一个超时计时器，其重传时间应比数据在分组传输的平均往返时间更长一些。这种自动重传方式常称为 <strong>自动重传请求 ARQ 。</strong> 另外在停止等待协议中若收到重复分组，就丢弃该分组，但同时还要发送确认。<strong>连续 ARQ 协议</strong> 可提高信道利用率。发送维持一个发送窗口，凡位于发送窗口内的分组可连续发送出去，而不需要等待对方确认。接收方一般采用累积确认，对按序到达的最后一个分组发送确认，表明到这个分组位置的所有分组都已经正确收到了。</p>
<p><strong>确认丢失和确认迟到：</strong></p>
<ul>
<li><strong>确认丢失 ：</strong> 确认消息在传输过程丢失。当 A 发送 M1 消息，B 收到后，B 向 A 发送了一个 M1 确认消息，但却在传输过程中丢失。而 A 并不知道，在超时计时过后，A 重传 M1 消息，B 再次收到该消息后采取以下两点措施：1. 丢弃这个重复的 M1 消息，不向上层交付。 2. 向 A 重新发送确认消息。</li>
<li><strong>确认迟到：</strong> 确认消息在传输过程中迟到。A 发送 M1 消息，B 收到并发送确认。在超时时间内没有收到确认消息，A 重传 M1 消息，B 仍然收到并继续发送确认消息（B 收到了 2 份 M1）。此时 A 收到了 B 第二次发送的确认消息。接着发送其他数据。过了一会，A 收到了 B 第一次发送的对 M1 的确认消息（A 也收到了 2 份确认消息）。处理如下：1. A 收到重复的确认后，直接丢弃。2. B 收到重复的 M1 后，也直接丢弃重复的 M1。</li>
</ul>
<h2 id="滑动窗口和流量控制"><a href="#滑动窗口和流量控制" class="headerlink" title="滑动窗口和流量控制"></a>滑动窗口和流量控制</h2><p>TCP 利用滑动窗口实现流量控制。滑动窗口大小就是指无需等待确认应答，而可以继续发送数据的最大值。窗口的实现实际上是操作系统开辟的一个缓存空间，发送方主机在等到确认应答返回之前，必须在缓冲区中保留已发送的数据。如果按期收到确认应答，此时数据就可以从缓存区清除。</p>
<p>假设窗口大小为 3 个 TCP 段，那么发送方就可以「连续发送」 3 个 TCP 段，并且中途若有 ACK 丢失，可以通过「下一个确认应答进行确认」。如下图：</p>
<p><img src="https://raw.githubusercontent.com/zodical416/picto/master/20220215180509.png"></p>
<p>图中的 ACK 600 确认应答报文丢失，也没关系，因为可以通过下一个确认应答进行确认，只要发送方收到了 ACK 700 确认应答，就意味着 700 之前的所有数据「接收方」都收到了。这个模式就叫累计确认或者累计应答。</p>
<h3 id="窗口的大小"><a href="#窗口的大小" class="headerlink" title="窗口的大小"></a>窗口的大小</h3><p>TCP 头里有一个字段叫 Window，也就是窗口大小。这个字段是接收端告诉发送端自己还有多少缓冲区可以接收数据。于是发送端就可以根据这个接收端的处理能力来发送数据，而不会导致接收端处理不过来。因此，滑动窗口的大小通常是由接收方决定的。</p>
<h3 id="接收窗口和发送窗口的大小是相等的吗？"><a href="#接收窗口和发送窗口的大小是相等的吗？" class="headerlink" title="接收窗口和发送窗口的大小是相等的吗？"></a>接收窗口和发送窗口的大小是相等的吗？</h3><p>并不是完全相等，接收窗口的大小是约等于发送窗口的大小的。</p>
<p>因为滑动窗口并不是一成不变的。比如，当接收方的应用进程读取数据的速度非常快的话，这样的话接收窗口可以很快的就空缺出来。那么新的接收窗口大小，是通过 TCP 报文中的 Windows 字段来告诉发送方。那么这个传输过程是存在时延的，所以接收窗口和发送窗口是约等于的关系。</p>
<h3 id="什么是流量控制？"><a href="#什么是流量控制？" class="headerlink" title="什么是流量控制？"></a>什么是流量控制？</h3><p>发送方不能无脑发数据给接收方，要考虑接收方处理能力。如果一直无脑发数据给对方，但对方处理不过来，那么就会导致触发重发机制，从而导致网络流量的无端的浪费。</p>
<p>为了解决这种现象发生，TCP 提供一种机制可以让「发送方」根据「接收方」的实际接收能力控制发送的数据量，这就是所谓的流量控制。</p>
<h1 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h1><p>在某段时间，若对网络中某一资源的需求超过了该资源所能提供的可用部分，网络的性能就要变坏。这种情况就叫<strong>拥塞</strong>。拥塞控制就是为了防止过多的数据注入到网络中，这样就可以使网络中的路由器或链路不致过载。拥塞控制所要做的都有一个前提，就是网络能够承受现有的网络负荷。</p>
<p>拥塞控制与流量控制的区别在于，拥塞控制是一个全局性的过程，涉及到所有的主机，所有的路由器，以及与降低网络传输性能有关的所有因素。相反，流量控制往往是点对点通信量的控制，是个端到端的问题。流量控制所要做到的就是抑制发送端发送数据的速率，以便使接收端来得及接收。</p>
<h2 id="什么是拥塞窗口"><a href="#什么是拥塞窗口" class="headerlink" title="什么是拥塞窗口"></a>什么是拥塞窗口</h2><p>为了进行拥塞控制，TCP 发送方要维持一个 <strong>拥塞窗口(cwnd)</strong> 的状态变量。拥塞控制窗口的大小取决于网络的拥塞程度，并且动态变化。发送方让自己的发送窗口取为拥塞窗口和接收方的接受窗口中较小的一个。</p>
<p>拥塞窗口 cwnd 变化的规则：</p>
<ul>
<li>只要网络中没有出现拥塞，cwnd 就会增大；</li>
<li>但网络中出现了拥塞，cwnd 就减少。</li>
</ul>
<h2 id="拥塞控制有哪些控制算法？"><a href="#拥塞控制有哪些控制算法？" class="headerlink" title="拥塞控制有哪些控制算法？"></a>拥塞控制有哪些控制算法？</h2><p>TCP 的拥塞控制采用了四种算法，即 <strong>慢开始</strong> 、 <strong>拥塞避免</strong> 、<strong>快重传</strong> 和 <strong>快恢复</strong>。</p>
<h3 id="慢开始"><a href="#慢开始" class="headerlink" title="慢开始"></a>慢开始</h3><p>慢开始算法的思路是当主机开始发送数据时，如果立即把大量数据字节注入到网络，那么可能会引起网络阻塞，因为现在还不知道网络的符合情况。经验表明，较好的方法是先探测一下，即由小到大逐渐增大发送窗口，也就是由小到大逐渐增大拥塞窗口数值。cwnd 初始值为 1，每经过一个传播轮次，cwnd 加倍。</p>
<h3 id="拥塞避免"><a href="#拥塞避免" class="headerlink" title="拥塞避免"></a>拥塞避免</h3><p>拥塞避免算法的思路是让拥塞窗口 cwnd 缓慢增大，即每经过一个往返时间 RTT 就把发送放的 cwnd 加 1.</p>
<h3 id="快重传与快恢复"><a href="#快重传与快恢复" class="headerlink" title="快重传与快恢复"></a>快重传与快恢复</h3><p>在 TCP/IP 中，快速重传和恢复（fast retransmit and recovery，FRR）是一种拥塞控制算法，它能快速恢复丢失的数据包。没有 FRR，如果数据包丢失了，TCP 将会使用定时器来要求传输暂停。在暂停的这段时间内，没有新的或复制的数据包被发送。有了 FRR，如果接收机接收到一个不按顺序的数据段，它会立即给发送机发送一个重复确认。如果发送机接收到三个重复确认，它会假定确认件指出的数据段丢失了，并立即重传这些丢失的数据段。有了 FRR，就不会因为重传时要求的暂停被耽误。然而当有多个数据信息包在某一段很短的时间内丢失时，该算法就不能很有效地工作。</p>
<h1 id="DNS-原理"><a href="#DNS-原理" class="headerlink" title="DNS 原理"></a>DNS 原理</h1><p>DNS 即域名系统，其是用于实现域名和 IP 地址相互映射的一个分布式数据库。其基本解析流程为：</p>
<ol>
<li><p>客户端输入域名，即由浏览器发起一个 DNS 解析请求，浏览器会首先在自己的缓存中查找 URL 对应的 IP 地址，如果缓存中没有，会进入下一步</p>
</li>
<li><p>通过计算机本地的 Host 文件配置，可以设置 URL 和 IP 地址之间的映射关系，因此会查找本地的 Host 文件，看是否有 IP 地址的缓存</p>
</li>
<li><p>如果仍然没有获得 IP 地址，会请求本地 DNS 服务器，通过本地运营商获取 URL 和 IP 的映射关系。由于本地 DNS 物理距离较近、性能较好，因此很快返回域名解析结果。</p>
</li>
<li><p>如果本地缓存服务器中找不到结果，则会首先向根服务器查询，根服务器中记录各个顶级域所在服务器的位置，例如向根服务器请求 .cn 时，根服务器会返回 .cn 服务器的位置信息</p>
</li>
<li><p>返回顶级域名服务器地址后，访问对应的服务器，并且返回 Name Server 服务器地址。所谓的 Name Server 就算网站注册的域名服务器，上面保存了 URL 和 对应的 IP 信息。</p>
</li>
<li><p>Name Server 会把指定域名的 A 记录或者 CNAME 返回给本地服务器，并且设置一个 TTL</p>
<p>A（Address）记录用来指定主机名对应的 IP 地址记录，CNAME 即别名记录，TTL 即 time to live，即过期时间</p>
</li>
<li><p>如果获取的是 A 记录，则可以直接访问，如果获取到的是 CNAME，那么会将其传给 GTM Server</p>
<p>GTM 即全局流量管理，传给 GTM 是希望通过其负载均衡机制，帮助用户找到最适合自己的服务器 IP 地址。</p>
</li>
<li><p>获得 IP 地址，进行访问。</p>
</li>
</ol>
<h1 id="在浏览器中输入-url-地址-gt-gt-显示主页的过程"><a href="#在浏览器中输入-url-地址-gt-gt-显示主页的过程" class="headerlink" title="在浏览器中输入 url 地址 -&gt;&gt; 显示主页的过程"></a>在浏览器中输入 url 地址 -&gt;&gt; 显示主页的过程</h1><p>总体来说分为以下几个过程:</p>
<ol>
<li>输入地址</li>
<li>浏览器查找域名的 IP 地址</li>
<li>浏览器向 web 服务器发送一个 HTTP 请求</li>
<li>服务器的永久重定向响应</li>
<li>服务器处理请求</li>
<li>服务器返回一个 HTTP 响应</li>
<li>浏览器显示 HTML</li>
<li>浏览器发送请求获取嵌入在 HTML 中的资源（如图片、音频、视频、CSS、JS等等）</li>
</ol>
<h2 id="输入地址"><a href="#输入地址" class="headerlink" title="输入地址"></a>输入地址</h2><p>当我们开始在浏览器中输入网址的时候，浏览器其实就已经在智能的匹配可能得 url 了，他会从历史记录，书签等地方，找到已经输入的字符串可能对应的 url，然后给出智能提示，让你可以补全url地址。对于 google 的chrome 的浏览器，他甚至会直接从缓存中把网页展示出来，就是说，你还没有按下 enter，页面就出来了。</p>
<h2 id="浏览器查找域名的-IP-地址"><a href="#浏览器查找域名的-IP-地址" class="headerlink" title="浏览器查找域名的 IP 地址"></a>浏览器查找域名的 IP 地址</h2><ol>
<li>查看本地硬盘的 hosts 文件：请求一旦发起，浏览器首先要做的事情就是解析这个域名，一般来说，浏览器会首先查看本地硬盘的 hosts 文件，看看其中有没有和这个域名对应的规则，如果有的话就直接使用 hosts 文件里面的 ip 地址。</li>
<li>查询本地DNS服务器：如果在本地的 hosts 文件没有能够找到对应的 ip 地址，浏览器会发出一个 DNS请求到本地DNS服务器 。本地DNS服务器一般都是你的网络接入服务器商提供，比如中国电信，中国移动。</li>
<li>本地服务器查询缓存：查询你输入的网址的DNS请求到达本地DNS服务器之后，本地DNS服务器会首先查询它的缓存记录，如果缓存中有此条记录，就可以直接返回结果，此过程是递归的方式进行查询。如果没有，本地DNS服务器还要向DNS根服务器进行查询。</li>
<li>查询根DNS服务器：如果根 DNS 服务器没有记录具体的域名和 IP 地址的对应关系，而是告诉本地 DNS 服务器，你可以到域服务器上去继续查询，并给出域服务器的地址。这种过程是迭代的过程。</li>
<li>查询域服务器：本地DNS服务器继续向域服务器发出请求，域服务器收到请求之后，也不会直接返回域名和IP地址的对应关系，而是告诉本地DNS服务器，你的域名的解析服务器的地址。</li>
<li>向域名解析服务器发出请求：最后，本地DNS服务器向域名的解析服务器发出请求，这时就能收到一个域名和IP地址对应关系，本地DNS服务器不仅要把IP地址返回给用户电脑，还要把这个对应关系保存在缓存中，以备下次别的用户查询时，可以直接返回结果，加快网络访问。</li>
</ol>
<p><img src="https://raw.githubusercontent.com/zodical416/picto/master/20220215222710.png"></p>
<h2 id="浏览器向-web-服务器发送一个-HTTP-请求"><a href="#浏览器向-web-服务器发送一个-HTTP-请求" class="headerlink" title="浏览器向 web 服务器发送一个 HTTP 请求"></a>浏览器向 web 服务器发送一个 HTTP 请求</h2><p>拿到域名对应的IP地址之后，浏览器会以一个随机端口（1024&lt;端口&lt;65535）向服务器的WEB程序（常用的有 httpd,nginx 等）80端口发起TCP的连接请求。这个连接请求到达服务器端后（这中间通过各种路由设备，局域网内除外），进入到网卡，然后是进入到内核的TCP/IP协议栈（用于识别该连接请求，解封包，一层一层的剥开），还有可能要经过Netfilter防火墙（属于内核的模块）的过滤，最终到达WEB程序，最终建立了TCP/IP的连接。　</p>
<p>建立了TCP连接之后，发起一个http请求。一般的浏览器只能发起 GET 或者 POST 请求。客户端向服务器发起http请求的时候，会有一些请求信息，请求信息包含三个部分：</p>
<ul>
<li>请求方法 URI 协议/版本</li>
<li>请求头(Request Header)</li>
<li>请求正文</li>
</ul>
<h2 id="服务器的永久重定向响应"><a href="#服务器的永久重定向响应" class="headerlink" title="服务器的永久重定向响应"></a>服务器的永久重定向响应</h2><p>服务器给浏览器响应一个301永久重定向响应，这样浏览器就会访问<a target="_blank" rel="noopener" href="http://www.google.com/%E8%80%8C%E9%9D%9Ehttp://google.com/%E3%80%82">http://www.google.com/而非http://google.com/。</a></p>
<blockquote>
<p>301 和 302 状态码都表示重定向，就是说浏览器在拿到服务器返回的这个状态码后会自动跳转到一个新的URL地址，这个地址可以从响应的Location首部中获取（用户看到的效果就是他输入的地址A瞬间变成了另一个地址B）——这是它们的共同点。他们的不同在于。301表示旧地址A的资源已经被永久地移除了，搜索引擎在抓取新内容的同时也将旧的网址交换为重定向之后的网址；302表示旧地址A的资源还在（仍然可以访问），这个重定向只是临时地从旧地址A跳转到地址B，搜索引擎会抓取新的内容而保存旧的网址。</p>
</blockquote>
<p>当一个网站或者网页24—48小时内临时移动到一个新的位置，这时候就要进行302跳转，而使用301跳转的场景就是之前的网站因为某种原因需要移除掉，然后要到新的地址访问，是永久性的。</p>
<h2 id="服务器处理请求"><a href="#服务器处理请求" class="headerlink" title="服务器处理请求"></a>服务器处理请求</h2><p>后端服务器从在固定的端口接收到TCP报文开始，它会对TCP连接进行处理，对HTTP协议进行解析，并按照报文格式进一步封装成HTTP Request对象，供上层使用。</p>
<p>一些大一点的网站会将请求发送到反向代理服务器中，因为当网站访问量非常大，网站越来越慢，一台服务器已经不够用了。于是将同一个应用部署在多台服务器上，将大量用户的请求分配给多台机器处理。</p>
<p>此时，客户端不是直接通过HTTP协议访问某网站应用服务器，而是先请求到Nginx，Nginx再请求应用服务器，然后将结果返回给客户端，这里Nginx的作用是反向代理服务器。</p>
<p><img src="https://raw.githubusercontent.com/zodical416/picto/master/20220215230219.png"></p>
<p>通过 Nginx 的反向代理，我们就能够到达web服务器，服务端脚本处理我们的请求，访问我们的数据库，获取需要获取的内容等等</p>
<blockquote>
<p>客户端本来可以直接通过HTTP协议访问某网站应用服务器，网站管理员可以在中间加上一个Nginx，客户端请求Nginx，Nginx请求应用服务器，然后将结果返回给客户端，此时Nginx就是反向代理服务器。</p>
</blockquote>
<h2 id="服务器返回一个-HTTP-响应"><a href="#服务器返回一个-HTTP-响应" class="headerlink" title="服务器返回一个 HTTP 响应"></a>服务器返回一个 HTTP 响应</h2><p>经过前面的6个步骤，服务器收到了我们的请求，也处理我们的请求，到这一步，它会把它的处理结果返回，也就是返回一个HTPP响应。HTTP响应与HTTP请求相似，HTTP响应也由3个部分构成，分别是：</p>
<ul>
<li>状态行</li>
<li>响应头</li>
<li>响应正文</li>
</ul>
<h2 id="浏览器显示-HTML"><a href="#浏览器显示-HTML" class="headerlink" title="浏览器显示 HTML"></a>浏览器显示 HTML</h2><p>在浏览器没有完整接受全部HTML文档时，它就已经开始显示这个页面了，在此只介绍 webkit 的渲染过程，这个过程包括：</p>
<p>解析 html 以构建 dom 树 -&gt; 构建 render 树 -&gt; 布局 render 树 -&gt; 绘制 render 树</p>
<p>浏览器是一个边解析边渲染的过程。首先浏览器解析HTML文件构建DOM树，然后解析CSS文件构建渲染树，等到渲染树构建完成后，浏览器开始布局渲染树并将其绘制到屏幕上。这个过程比较复杂，涉及到两个概念: reflow(回流)和repain(重绘)。</p>
<p>DOM节点中的各个元素都是以盒模型的形式存在，这些都需要浏览器去计算其位置和大小等，这个过程称为 reflow；当盒模型的位置，大小以及其他属性，如颜色，字体，等确定下来之后，浏览器便开始绘制内容，这个过程称为repain。</p>
<p>页面在首次加载时必然会经历reflow和repain。reflow和repain过程是非常消耗性能的，尤其是在移动设备上，它会破坏用户体验，有时会造成页面卡顿。所以我们应该尽可能少的减少reflow和repain。</p>
<p>当文档加载过程中遇到js文件，html文档会挂起渲染（加载解析渲染同步）的线程，不仅要等待文档中js文件加载完毕，还要等待解析执行完毕，才可以恢复html文档的渲染线程。</p>
<blockquote>
<p>JS有可能会修改DOM，最为经典的document.write，这意味着，在JS执行完成前，后续所有资源的下载可能是没有必要的，这是js阻塞后续资源下载的根本原因。所以我们平时的代码中，js是放在html文档末尾的。</p>
</blockquote>
<p>JS的解析是由浏览器中的JS解析引擎完成的，JS是单线程运行，也就是说，在同一个时间内只能做一件事，所有的任务都需要排队，前一个任务结束，后一个任务才能开始。但是又存在某些任务比较耗时，如IO读写等，所以需要一种机制可以先执行排在后面的任务，这就是：同步任务(synchronous)和异步任务(asynchronous)。</p>
<h2 id="浏览器发送请求获取嵌入在-HTML-中的资源"><a href="#浏览器发送请求获取嵌入在-HTML-中的资源" class="headerlink" title="浏览器发送请求获取嵌入在 HTML 中的资源"></a>浏览器发送请求获取嵌入在 HTML 中的资源</h2><p>其实这个步骤可以并列在上一步中，在浏览器显示HTML时，它会注意到需要获取其他地址内容的标签。这时，浏览器会发送一个获取请求来重新获得这些文件。</p>
<h2 id="整个过程使用到的协议"><a href="#整个过程使用到的协议" class="headerlink" title="整个过程使用到的协议"></a>整个过程使用到的协议</h2><p><img src="https://raw.githubusercontent.com/zodical416/picto/master/20220215231218.png"></p>
<h1 id="HTTP-的状态码"><a href="#HTTP-的状态码" class="headerlink" title="HTTP 的状态码"></a>HTTP 的状态码</h1><p><img src="https://raw.githubusercontent.com/zodical416/picto/master/20220215231307.png"></p>
<h1 id="HTTP-的长连接与短连接"><a href="#HTTP-的长连接与短连接" class="headerlink" title="HTTP 的长连接与短连接"></a>HTTP 的长连接与短连接</h1><p>在 HTTP/1.0 中默认使用短连接。也就是说，客户端和服务器每进行一次 HTTP 操作，就建立一次连接，任务结束就中断连接。而从 HTTP/1.1 起，默认使用长连接，用以保持连接特性。</p>
<p>在使用长连接的情况下，当一个网页打开完成后，客户端和服务器之间用于传输 HTTP 数据的 TCP 连接不会关闭，客户端再次访问这个服务器时，会继续使用这一条已经建立的连接。</p>
<h1 id="HTTP-是不保存状态的协议-那应该如何保存用户状态"><a href="#HTTP-是不保存状态的协议-那应该如何保存用户状态" class="headerlink" title="HTTP 是不保存状态的协议, 那应该如何保存用户状态?"></a>HTTP 是不保存状态的协议, 那应该如何保存用户状态?</h1><p>HTTP 协议自身不对请求和响应之间的通信状态进行保存，因此提出了 Session 机制来解决这一问题。Session 的主要作用就是通过服务端记录用户的状态。典型的场景是购物车，当你要添加商品到购物车的时候，系统不知道是哪个用户操作的，因为 HTTP 协议是无状态的。服务端给特定的用户创建特定的 Session 之后就可以标识这个用户并且跟踪这个用户了。（一般情况下，服务器会在一定时间内保存这个 Session，过了时间限制，就会销毁这个 Session）</p>
<p>在服务端保存 Session 的方法很多，最常用的就是内存和数据库(比如是使用内存数据库 redis 保存)。既然 Session 存放在服务器端，那么我们如何实现 Session 跟踪呢？大部分情况下，我们都是通过在 Cookie 中附加一个 Session ID 来方式来跟踪。</p>
<h1 id="Cookie-的作用是什么-和-Session-有什么区别？"><a href="#Cookie-的作用是什么-和-Session-有什么区别？" class="headerlink" title="Cookie 的作用是什么? 和 Session 有什么区别？"></a>Cookie 的作用是什么? 和 Session 有什么区别？</h1><p>Cookie 和 Session 都是用来跟踪浏览器用户身份的会话方式，但是两者的应用场景不太一样。</p>
<p>Cookie 一般用来保存用户信息，例如已登录过的用户信息、单点登录功能的实现等等；Session 的主要作用就是通过服务端记录用户的状态。</p>
<p>Cookie 数据保存在客户端(浏览器端)，Session 数据保存在服务器端。</p>
<h1 id="HTTP-1-0-和-HTTP-1-1-的主要区别是什么？"><a href="#HTTP-1-0-和-HTTP-1-1-的主要区别是什么？" class="headerlink" title="HTTP 1.0 和 HTTP 1.1 的主要区别是什么？"></a>HTTP 1.0 和 HTTP 1.1 的主要区别是什么？</h1><ol>
<li>长连接：在 HTTP 1.0 中默认采用短连接，而 HTTP 1.1 中默认采用长连接。HTTP/1.1 的持续连接有非流水线方式和流水线方式 。流水线方式是客户在收到 HTTP 的响应报文之前就能接着发送新的请求报文。与之相对应的非流水线方式是客户在收到前一个响应后才能发送下一个请求。</li>
<li>错误状态响应码：在 HTTP1.1 中新增了 24 个错误状态响应码，如 409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除。</li>
<li>缓存处理</li>
<li>带宽优化及网络连接的使用：HTTP1.0 中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能；HTTP1.1 则在请求头引入了 range 头域，它允许只请求资源的某个部分，这样就方便了开发者自由的选择以便于充分利用带宽和连接。</li>
</ol>
<h1 id="URI-与-URL-的主要区别是什么？"><a href="#URI-与-URL-的主要区别是什么？" class="headerlink" title="URI 与 URL 的主要区别是什么？"></a>URI 与 URL 的主要区别是什么？</h1><ul>
<li>URI(Uniform Resource Identifier) 是统一资源标志符，可以唯一标识一个资源。</li>
<li>URL(Uniform Resource Locator) 是统一资源定位符，可以提供该资源的路径。它是一种具体的 URI，即 URL 可以用来标识一个资源，而且还指明了如何 locate 这个资源。</li>
</ul>
<p>URI 的作用像身份证号一样，URL 的作用更像家庭住址一样。</p>
<h1 id="HTTP-与-HTTPS-的主要区别是什么？"><a href="#HTTP-与-HTTPS-的主要区别是什么？" class="headerlink" title="HTTP 与 HTTPS 的主要区别是什么？"></a>HTTP 与 HTTPS 的主要区别是什么？</h1><ol>
<li>端口：HTTP 的 URL 由“http://”起始且默认使用端口80，而HTTPS的URL由“https://”起始且默认使用端口443。</li>
<li>安全性和资源消耗： HTTP 协议运行在 TCP 之上，所有传输的内容都是明文，客户端和服务器端都无法验证对方的身份。HTTPS 是运行在 SSL/TLS 之上的 HTTP 协议，SSL/TLS 运行在 TCP 之上。所有传输的内容都经过加密，加密采用对称加密，但对称加密的密钥用服务器方的证书进行了非对称加密。所以说，HTTP 安全性没有 HTTPS 高，但是 HTTPS 比 HTTP 耗费更多服务器资源。</li>
</ol>
<blockquote>
<p>对称加密：密钥只有一个，加密解密为同一个密码，且加解密速度快，典型的对称加密算法有 DES、AES 等；</p>
<p>非对称加密：密钥成对出现（且根据公钥无法推知私钥，根据私钥也无法推知公钥），加密解密使用不同密钥（公钥加密需要私钥解密，私钥加密需要公钥解密），相对对称加密速度较慢，典型的非对称加密算法有 RSA、DSA 等。</p>
</blockquote>
<h1 id="GET-和-POST-的区别、HTTP请求的方法"><a href="#GET-和-POST-的区别、HTTP请求的方法" class="headerlink" title="GET 和 POST 的区别、HTTP请求的方法"></a>GET 和 POST 的区别、HTTP请求的方法</h1><p>GET 方法请求一个制定资源的表示形式，使用 GET 的请求应该只用于获取数据</p>
<p>POST 方法会向指定资源提交数据进行处理请求（例如提交表单或上传文件），该请求会导致新资源的建立、已有资源的修改</p>
<h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><ol>
<li>GET 在浏览器回退时是无害的，而 POST 则会再次提交请求</li>
<li>GET 请求会被缓存，而 POST 请求不会，除非手动设置</li>
<li>GET 请求可被收藏为书签，POST 不能</li>
<li>GET 请求参数会被保存在历史记录中，POST 不能</li>
<li>GET 请求只能用 URL 编码，请求会直接暴露在 URL 上，POST 支持多种编码方式，请求放在请求体中</li>
</ol>
<h2 id="请求方法"><a href="#请求方法" class="headerlink" title="请求方法"></a>请求方法</h2><ol>
<li>GET</li>
<li>POST</li>
<li>HEAD：类似于 GET 请求，只不过返回的响应中没有具体的内容，用于获取报头</li>
</ol>
<p>HTTP 1.1 新增了几种：</p>
<ol>
<li>PUT</li>
<li>DELETE</li>
<li>CONNECT</li>
<li>OPTIONS</li>
<li>TRACE</li>
<li>PATCH</li>
</ol>
<h1 id="有哪些有状态协议"><a href="#有哪些有状态协议" class="headerlink" title="有哪些有状态协议"></a>有哪些有状态协议</h1><p>很多应用层协议都是有状态的，例如 BGP 路由协议、OSPF 路由协议、TFTP 文件传输协议</p>
<h1 id="HTTP-1-0-1-1-2-0-3-0"><a href="#HTTP-1-0-1-1-2-0-3-0" class="headerlink" title="HTTP 1.0/1.1/2.0/3.0"></a>HTTP 1.0/1.1/2.0/3.0</h1><h2 id="HTTP-1-0"><a href="#HTTP-1-0" class="headerlink" title="HTTP 1.0"></a>HTTP 1.0</h2><p>无状态的应用层协议，浏览器每次请求都需要与服务器建立一个TCP连接，服务器处理完成以后立即断开TCP连接(无连接)，服务器不跟踪也每个客户单，也不记录过去的请求(无状态)。</p>
<p>这种无状态性可以借助cookie/session机制来做身份认证和状态记录。</p>
<p>存在的问题：</p>
<ol>
<li><p>无法复用连接</p>
<p>每次发送请求，都需要进行一次TCP连接，而TCP的连接释放过程又是比较费事的。这种无连接的特性会使得网络的利用率变低。</p>
</li>
<li><p>队头阻塞</p>
<p>由于HTTP1.0规定下一个请求必须在前一个请求响应到达之前才能发送，假设前一个请求响应一直不到达，那么下一个请求就不发送，后面的请求就阻塞了。</p>
</li>
</ol>
<h2 id="HTTP-1-1"><a href="#HTTP-1-1" class="headerlink" title="HTTP 1.1"></a>HTTP 1.1</h2><p>特性包括长连接、管道化</p>
<h3 id="长连接"><a href="#长连接" class="headerlink" title="长连接"></a>长连接</h3><p>HTTP1.1增加Connection字段，通过设置Keep-Alive保持HTTP连接不断开。避免每次客户端与服务器请求都要重复建立释放建立TCP连接。提高了网络的利用率。</p>
<h3 id="管道化"><a href="#管道化" class="headerlink" title="管道化"></a>管道化</h3><p>长连接使得管道化成为可能，将先进先出队列由客户端转移到服务端</p>
<p>允许打开多个 TCP 会话，才算实现真正的并行传输</p>
<h3 id="缓存处理"><a href="#缓存处理" class="headerlink" title="缓存处理"></a>缓存处理</h3><p>加入了缓存处理机制，支持断点传输，并增加了 Host 字段，使得一个服务器得以创建多个 Web 站点</p>
<h2 id="HTTP-2-0"><a href="#HTTP-2-0" class="headerlink" title="HTTP 2.0"></a>HTTP 2.0</h2><h3 id="二进制分帧"><a href="#二进制分帧" class="headerlink" title="二进制分帧"></a>二进制分帧</h3><p>HTTP2.0 在应用层和传输层之间增加了一个二进制分层帧，在二进制分帧层上，http2.0会将所有传输信息分割为更小的消息和帧，并对它们采用二进制格式的编码将其封装。这一做法突破了 HTTP 1.x 的性能限制，改进传输性能，实现了低延迟和高吞吐量。</p>
<h3 id="多路复用-连接共享"><a href="#多路复用-连接共享" class="headerlink" title="多路复用 / 连接共享"></a>多路复用 / 连接共享</h3><p>所有HTTP2.0通信都在一个TCP链接上完成，这个链接可以承载任意流量的双向数据流。</p>
<p>每个数据流以消息的形式发送，而消息由一或多个帧组成。这些帧可以乱序发送，然后再根据每个帧头部的流标识符(Stream_id)重新封装。</p>
<p>http 2.0 连接都是持久化的，而且客户端与服务器之间也只需要一个连接（每个域名一个连接）即可。http2连接可以承载数十或数百个流的复用，多路复用意味着来自很多流的数据包能够混合在一起通过同样连接传输。当到达终点时，再根据不同帧首部的流标识符重新连接将不同的数据流进行组装。实现了真正的并行传输。</p>
<h3 id="头部压缩"><a href="#头部压缩" class="headerlink" title="头部压缩"></a>头部压缩</h3><p>在HTTP1.X中，头部元数据都是以纯文本的形式发送的，通常会给每个请求增加500-8000字节的负荷。</p>
<p>比如cookie，默认情况下，浏览器会在每次请求的时候，把cookie附在header上面发给服务器。</p>
<p>HTTP2.0使用encoder来减少需要传输的header大小，通讯双方各自cache一份header_files表，既避免重复header的传输，又减少了需要传输的大小。</p>
<p>高效的压缩算法可以很大的压缩header，减少发送包的数量从而降低延迟。</p>
<h3 id="请求优先级"><a href="#请求优先级" class="headerlink" title="请求优先级"></a>请求优先级</h3><p>把http消息分为很多独立帧之后，就可以通过优化这些帧的交错和传输顺序进一步优化性能。每个流都可以带有一个31比特的优先值：0 表示最高优先级；2的31次方-1 表示最低优先级。</p>
<p>服务器可以根据流的优先级，控制资源分配（CPU、内存、带宽），而在响应数据准备好之后，优先将最高优先级的帧发送给客户端。高优先级的流都应该优先发送，但又不会绝对的。绝对地准守，可能又会引入首队阻塞的问题：高优先级的请求慢导致阻塞其他资源交付。</p>
<p>分配处理资源和客户端与服务器间的带宽，不同优先级的混合也是必须的。客户端会指定哪个流是最重要的，有一些依赖参数，这样一个流可以依赖另外一个流。优先级别可以在运行时动态改变，当用户滚动页面时，可以告诉浏览器哪个图像是最重要的，你也可以在一组流中进行优先筛选，能够突然抓住重点流。</p>
<ul>
<li>优先级最高：主要的html</li>
<li>优先级高：CSS文件</li>
<li>优先级中：js文件</li>
<li>优先级低：图片</li>
</ul>
<h3 id="服务器推送"><a href="#服务器推送" class="headerlink" title="服务器推送"></a>服务器推送</h3><p>服务器除了最初请求的响应外，服务器还可以额外向客户端推送资源，而无需客户端明确的需求。</p>
<h2 id="HTTP-3-0"><a href="#HTTP-3-0" class="headerlink" title="HTTP 3.0"></a>HTTP 3.0</h2><p>即 QUIC 协议，是一个使用UDP来替代TCP的协议</p>
<h3 id="0-RTT"><a href="#0-RTT" class="headerlink" title="0-RTT"></a>0-RTT</h3><p>缓存当前会话的上下文，下次恢复会话的时候，只需要将之前的缓存传递给服务器，验证通过，就可以进行传输了。</p>
<p>RTT：往返时延，0-RTT建连指的是：</p>
<p>传输层0-RTT就能建立连接</p>
<p>加密层0-RTT就能建立加密连接</p>
<h3 id="多路复用"><a href="#多路复用" class="headerlink" title="多路复用"></a>多路复用</h3><p>基于UDP，一个连接上的多个stream之间没有依赖，即使丢包，只需要重发丢失的包即可，不需要重传整个连接。</p>
<h3 id="更好的移动端表现"><a href="#更好的移动端表现" class="headerlink" title="更好的移动端表现"></a>更好的移动端表现</h3><p>QUIC在移动端的表现比TCP好，因为TCP是基于IP识别连接，而QUIC是通过ID识别链接。 无论网络环境如何变化，只要ID不便，就能迅速重新连上。</p>
<h3 id="加密认证的根文"><a href="#加密认证的根文" class="headerlink" title="加密认证的根文"></a>加密认证的根文</h3><p>TCP协议头没有经过任何加密和认证，在传输过程中很容易被中间网络设备篡改、注入和窃听。</p>
<p>QUIC除了个别报文，比如PUBLIC_RESET和CHLO，所有报文头部都是经过认证的，报文Body都是经过加密的。</p>
<p>所以只要对 QUIC 做任何更改，接收端都能及时发现，有效地降低了安全风险。</p>
<h3 id="向前纠错机制"><a href="#向前纠错机制" class="headerlink" title="向前纠错机制"></a>向前纠错机制</h3><p>每个数据包除了它本身的内容之外还包括了其他数据包的数据，因此少量的丢包可以通过其他包的冗余数据直接组装而无需重传。</p>
<p>向前纠错牺牲了每个数据包可以发送数据的上限，但是带来的提升大于丢包导致的数据重传，因为数据重传将会消耗更多的时间(包括确认数据包丢失，请求重传，等待新数据包等步骤的时间消耗)。</p>
<h1 id="为什么四次挥手等待-2-MSL"><a href="#为什么四次挥手等待-2-MSL" class="headerlink" title="为什么四次挥手等待 2 MSL"></a>为什么四次挥手等待 2 MSL</h1><p>MSL，Maximum Segment Lifetime，报文最大生存时间，指的是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃。</p>
<p>之所以等待 2 MSL，是因为在发送了第三次挥手之后，网络中仍然有可能存在来自发送方的数据包，当这些发送方的数据包被接收方处理后又会向对方发送响应，所以一来一回需要等待 2 倍的时间。</p>
<p>比如，三次挥手方没有收到断开连接的最后的 ACK 报文，就会再次发送 FIN 报文，另一方接收到 FIN之后，会再次重发 ACK 报文。</p>
<p>四次挥手方发送 ACK 报文后，报文会在一个 MSL 后失效，如果失效了，那么三次挥手方会重发 FIN 报文，这个报文同样会在一个 MSL 后失效。这样一来一回恰好是两个 MSL，也就是说这两个 MSL 内，如果没有故障，三次挥手方必然会收到 ACK，因此等 2 个 MSL 是为了防止 ACK 消息丢失，三次挥手方再次发送的 FIN 消息没有收到。</p>
<p>因此，2MSL 时长其实是相当于至少允许报文丢失一次</p>
<p>为什么不是 4 或者 8 MSL 的时长呢？你可以想象一个丢包率达到百分之一的糟糕网络，连续两次丢包的概率只有万分之一，这个概率实在是太小了，忽略它比解决它更具性价比。</p>
<h1 id="301-和-302-状态码的区别"><a href="#301-和-302-状态码的区别" class="headerlink" title="301 和 302 状态码的区别"></a>301 和 302 状态码的区别</h1><p>301 适合永久重定向，代表所请求的资源已被永久定位到新位置，比较常用的场景是域名跳转。例如对 <a target="_blank" rel="noopener" href="http://www.baidu.com/">http://www.baidu.com</a> 的访问会跳转到 <a target="_blank" rel="noopener" href="https://www.baidu.com/">https://www.baidu.com</a></p>
<p>302 是临时重定向，即请求的资源现在临时从不同的 URL 响应请求。适合用来做临时跳转，比如未登录的用户访问用户中心会自动跳转到登录、访问 404 页面会重新定向到首页</p>
<p>总之，302 重定向只是暂时重定向，浏览器会抓取新内容并保留旧内容</p>
<p>301重定向是永久重定向，浏览器抓取新内容的同时将旧网址替换为了重定向后的网址</p>
<h1 id="HTTP、TCP、IP-三种协议中，接收端如何判断已接收完对端发送来的数据？"><a href="#HTTP、TCP、IP-三种协议中，接收端如何判断已接收完对端发送来的数据？" class="headerlink" title="HTTP、TCP、IP 三种协议中，接收端如何判断已接收完对端发送来的数据？"></a>HTTP、TCP、IP 三种协议中，接收端如何判断已接收完对端发送来的数据？</h1><ul>
<li>HTTP 协议的服务端响应报文含有 Content-Length 字段，明确的报文的长度，客户端能够根据该字段进行判断</li>
<li>TCP 协议需要接收方回传确认号。如果双方各自向对方请求下一个数据包，却没有响应对方的请求，那么说明数据已经传完了。有时数据发送方发送完毕，会发出中断连接请求，对方也能够得知已经发送完毕了</li>
<li>IP 协议是无连接协议，不会考虑对方是否发送完毕，如果IP数据报被分片发送，那么只有最后一个分片的 “还有分片” 字段 flag 置为0，之前的都为1</li>
</ul>
<h1 id="HTTP-状态码故障排除"><a href="#HTTP-状态码故障排除" class="headerlink" title="HTTP 状态码故障排除"></a>HTTP 状态码故障排除</h1><h2 id="5XX"><a href="#5XX" class="headerlink" title="5XX"></a>5XX</h2><h3 id="500"><a href="#500" class="headerlink" title="500"></a>500</h3><p>500 表示服务器端错误的响应状态码，代表所请求的服务器遇到意外情况，阻止其执行请求。可能是服务器端程序或配置发生了致命错误，需要对服务器进行检查。</p>
<p>这个状态码是一个通用状态码，对于该类错误，需要访问更详细的请求信息来确定错误</p>
<h3 id="501"><a href="#501" class="headerlink" title="501"></a>501</h3><p>表示所请求的方法不被服务器锁支持，无法被处理，服务器必须支持的方法只有 GET 与 HEAD</p>
<h3 id="502"><a href="#502" class="headerlink" title="502"></a>502</h3><p>502 BAD GATEWAY 表示作为网关或代理的服务器，从上游服务器中接收到的响应是无效的</p>
<p>说白了就是，网站突然有大量请求进来，服务器无法及时处理，出现了502，需要进行重启。如果重启后依旧发生 502，则可能是数据库出现死锁导致超时，需要重启数据库或杀死死锁的 SQL 进程</p>
<p>可能导致的原因：上游服务器处理超时、配置错误、负载高导致处理请求慢、数据库发生死锁、服务未启动等</p>
<h3 id="503"><a href="#503" class="headerlink" title="503"></a>503</h3><p>源服务器存在性能问题，可能是源服务器没有足够的容量支持请求速率</p>
<p>可能是收到 DDoS 攻击，造成系统带宽和资源超载、可能系统在进行维护、可能存在防火墙配置错误，例如在传递网络时，防火墙可能将来自 CDN 的请求识别为攻击并阻止它们</p>
<h3 id="504"><a href="#504" class="headerlink" title="504"></a>504</h3><p>网关超时，一般和 Nginx 的配置有关，可能 Nginx 设置了超时时间，如果在超时时间内没有收到响应，则会给客户端返回 504</p>
<h2 id="4XX"><a href="#4XX" class="headerlink" title="4XX"></a>4XX</h2><h3 id="400"><a href="#400" class="headerlink" title="400"></a>400</h3><p>主要有两种形式：bad request 为请求错误，invalid hostname 为域名不存在</p>
<p>Bad request 是由于明显的客户端错误，例如格式错误的请求语法，请求大小太大，无效的请求消息或者欺骗性的路由请求等，对于这类请求服务器不会处理</p>
<p>常见的原因有：</p>
<ol>
<li>前端提交数据的字段名称或类型与后端的实体类不一致，导致无法封装，例如需要 int 传回了 String</li>
<li>前端提交到后台的数据应该是 json 类型，而前端没有将对象转化为字符串类型</li>
</ol>
<p>解决方案：</p>
<ol>
<li>对照字段名称，确保类型一致性</li>
<li>使用 Stringify 将前端传递的对象转化为字符串</li>
</ol>
<p>还有可能是走代理用的 HTTP 协议，但是目标地址是 HTTPS</p>
<h3 id="401"><a href="#401" class="headerlink" title="401"></a>401</h3><p>请求授权失败，可能是没有验证，例如需要账号密码但是没有输入，或者没有权限</p>
<h3 id="403"><a href="#403" class="headerlink" title="403"></a>403</h3><p>服务器已经理解该请求，但是拒绝执行，可能是由于以下的几种原因</p>
<p>原因：</p>
<ul>
<li>IP 被列入黑名单</li>
<li>一定时间内过多访问此网站，被防火墙拒绝</li>
<li>网络域名解析到了空间，但是空间没有绑定此域名</li>
<li>网页脚本文件在当前目录下没有执行权限</li>
<li>以 HTTP 方式访问需要 SSL 连接的网址</li>
<li>身份验证失败</li>
<li>DNS 解析错误</li>
<li>服务器繁忙</li>
</ul>
<p>解决方法：</p>
<ol>
<li>重建 DNS 缓存</li>
<li>修改文件夹安全属性</li>
</ol>
<h3 id="404"><a href="#404" class="headerlink" title="404"></a>404</h3><p>请求失败，所请求的资源在服务器上未找到</p>
<p>可能是部署的路径不正确，排查 xml 中配置文件路径是否写错，并确保 Tomcat 服务器正常开启</p>
<h2 id="3XX"><a href="#3XX" class="headerlink" title="3XX"></a>3XX</h2><h3 id="300"><a href="#300" class="headerlink" title="300"></a>300</h3><p>请求的资源可在多处获得</p>
<h3 id="301-amp-302"><a href="#301-amp-302" class="headerlink" title="301 &amp; 302"></a>301 &amp; 302</h3><p>代表客户端请求的资源发生了变动，需要客户端用新的 URL 重新发送请求获取资源，即重定向</p>
<p>301 代表永久重定向，说明资源已经不复存在，需要用新的 URL 进行访问</p>
<p>302 代表临时重定向，暂时用另一个 URL 进行访问</p>
<p>301 和 302 都会在响应头使用字段 Location，指明后续要跳转的 URL</p>
<h1 id="HTTP-header-有哪些？"><a href="#HTTP-header-有哪些？" class="headerlink" title="HTTP header 有哪些？"></a>HTTP header 有哪些？</h1><h2 id="Request-的头部信息"><a href="#Request-的头部信息" class="headerlink" title="Request 的头部信息"></a>Request 的头部信息</h2><ol>
<li>HTTP 请求方式，包括 GET（发送请求）、POST、PUT（向服务器发生数据并存储在服务器内部）、HEAD（检查对象是否存在）、DELETE（删除文件）、TRACE（跟踪到服务器的路径）、OPTIONS（查询服务器性能）</li>
<li>HOST 请求的服务器域名地址</li>
<li>User=Agent 客户端运行的浏览器详细信息</li>
<li>Accept 指定客户端能够接收的内容类型</li>
<li>Keep-alive 此 HTTP 连接的时间</li>
<li>cookie</li>
</ol>
<h2 id="Response-的头部信息"><a href="#Response-的头部信息" class="headerlink" title="Response 的头部信息"></a>Response 的头部信息</h2><p>Response 中第一行叫状态行，由 HTTP 协议的版本号、状态码、状态消息 三部分组成</p>
<ol>
<li>Content-Length：表示服务器返回消息的长度</li>
<li>Content-type：返回数据的类型和字符编码格式</li>
<li>Date：当前时间</li>
</ol>
<h1 id="Http-与-TCP-中-keep-alive-的区别"><a href="#Http-与-TCP-中-keep-alive-的区别" class="headerlink" title="Http 与 TCP 中 keep-alive 的区别"></a>Http 与 TCP 中 keep-alive 的区别</h1><p>TCP 的 keep-alive 机制是为了探测对端是否正常存活，每过一段时间会向对端发送探测报文，如果对端响应探测报文，则证明连接正常，重置保活时间计数器。如果没有收到响应，那么在一定的探测时间间隔后，将继续发送保活探测报文，直到对端响应或达到探测循环次数上限都没有收到响应，此时需要中断连接</p>
<p>Http 的 keep-alive 机制是用来将 http 转为长连接的，在 1.0 中默认关闭、1.1 中默认开启。开启后，在一次 http 请求中，服务器进行响应后，不再直接断开 TCP 连接，而是将连接保持一段时间，在这段时间内，如果同一客户端再次向服务端发送请求，则能够复用连接。从而减少了反复创建和销毁 TCP 连接的损耗。</p>
<h1 id="TCP-的粘包与半包问题"><a href="#TCP-的粘包与半包问题" class="headerlink" title="TCP 的粘包与半包问题"></a>TCP 的粘包与半包问题</h1><h2 id="什么是粘包与半包"><a href="#什么是粘包与半包" class="headerlink" title="什么是粘包与半包"></a>什么是粘包与半包</h2><p>在客户端发送数据包给服务端时，服务端一次所读取到的字节数是不确定的，有多种情况：</p>
<ol>
<li>服务端分两次读取到了两个独立的数据包，没有错误发生</li>
<li>服务端一次收到了两个数据包，粘在一块，被称为 TCP 粘包</li>
<li>服务端分两次读取到了两个数据包，第一次读取到了完整的包和另外一个包的部分内容，第二次读取到了另外一个包的剩余内容，这被称之为 TCP 拆包</li>
<li>服务端分两次读取到了两个数据包，第一次读取到了包的部分内容，第二次读取到了之前未读完的包剩余内容和另一个包，发生了粘包与拆包</li>
<li>服务端TCP接收滑动窗口很小，数据包比较大，即服务端需要分多次才能将包接收完全，发生多次拆包</li>
</ol>
<h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><h3 id="粘包"><a href="#粘包" class="headerlink" title="粘包"></a>粘包</h3><p>TCP协议本身是面向连接的可靠传输协议，传输过程中客户端与服务器会维持连接，在连接不断开的情况下，将多个数据包发往服务器。但是如果发送的网络数据包太小，那么 TCP 协议本身会启动 Nagle 算法，对较小的数据包进行合并后再发送。这样服务器在接收到消息时就无法区分哪些数据包是客户端自己主动分开发送的，从而产生粘包。服务器在接收到数据后，放到缓存区中，如果消息没有及时从缓存区被取走，下次再取数据时可能会出现一次取出多个数据包的情况，造成粘包。</p>
<h3 id="半包"><a href="#半包" class="headerlink" title="半包"></a>半包</h3><p>一个数据包被分成了多次接收，可能是应用程序写入数据的字节大小太大，超过了套接字缓冲区的大小，导致只能分包发送；或者是进行了以最大报文段长度为分割的TCP分段。</p>
<h2 id="解决粘包半包问题"><a href="#解决粘包半包问题" class="headerlink" title="解决粘包半包问题"></a>解决粘包半包问题</h2><p>TCP底层无法保证数据包不被拆分与重组，这个问题只能通过上层应用协议栈的设计来解决。</p>
<ol>
<li>在包尾增加分隔符，比如回车换行符来进行分割（FTP 协议）</li>
<li>消息定长，例如每个报文大小为固定长度 200 字节，如果不够用空格补齐</li>
<li>将消息分为消息头和消息体，消息头中包含表示消息总长度的字段以供检测。</li>
</ol>

      
      <div>
    
        <div style="text-align:center;color: #ccc;font-size:14px;">-------------本文结束<i class="fa fa-paw"></i>感谢您的阅读-------------</div>
    
</div>
      
    </div>


    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/" rel="tag"># 计算机基础</a>
              <a href="/tags/%E5%85%AB%E8%82%A1/" rel="tag"># 八股</a>
              <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" rel="tag"># 计算机网络</a>
              <a href="/tags/TCP-IP/" rel="tag"># TCP/IP</a>
              <a href="/tags/Http/" rel="tag"># Http</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2022/02/15/%E5%9C%A8%E7%BA%BF%E5%8A%9E%E5%85%AC%E7%B3%BB%E7%BB%9F9%EF%BC%9A%E7%B3%BB%E7%BB%9F%E9%80%9A%E7%9F%A5%E6%A8%A1%E5%9D%97/" rel="prev" title="办公系统 9. 系统通知模块">
      <i class="fa fa-chevron-left"></i> 办公系统 9. 系统通知模块
    </a></div>
      <div class="post-nav-item">
    <a href="/2022/02/16/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/" rel="next" title="操作系统基础">
      操作系统基础 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9A%84%E5%88%86%E5%B1%82%E5%8F%82%E8%80%83%E6%A8%A1%E5%9E%8B"><span class="nav-number">1.</span> <span class="nav-text">计算机网络的分层参考模型</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BA%94%E7%94%A8%E5%B1%82"><span class="nav-number">1.1.</span> <span class="nav-text">应用层</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%90%E8%BE%93%E5%B1%82"><span class="nav-number">1.2.</span> <span class="nav-text">运输层</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BD%91%E7%BB%9C%E5%B1%82"><span class="nav-number">1.3.</span> <span class="nav-text">网络层</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82"><span class="nav-number">1.4.</span> <span class="nav-text">数据链路层</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%89%A9%E7%90%86%E5%B1%82"><span class="nav-number">1.5.</span> <span class="nav-text">物理层</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-number">1.6.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#TCP-%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%92%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B"><span class="nav-number">2.</span> <span class="nav-text">TCP 三次握手和四次挥手</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#TCP-%E7%9A%84%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B"><span class="nav-number">2.1.</span> <span class="nav-text">TCP 的三次握手</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B"><span class="nav-number">2.1.1.</span> <span class="nav-text">为什么要三次握手</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88TCP%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%9C%80%E5%90%8E%E8%BF%98%E8%A6%81%E5%8F%91%E9%80%81%E4%B8%80%E6%AC%A1%E7%A1%AE%E8%AE%A4%E5%91%A2%EF%BC%9F"><span class="nav-number">2.1.2.</span> <span class="nav-text">为什么TCP客户端最后还要发送一次确认呢？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AC%AC-2-%E6%AC%A1%E6%8F%A1%E6%89%8B%E4%BC%A0%E5%9B%9E%E4%BA%86-ACK%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%98%E8%A6%81%E4%BC%A0%E5%9B%9E-SYN%EF%BC%9F"><span class="nav-number">2.1.3.</span> <span class="nav-text">第 2 次握手传回了 ACK，为什么还要传回 SYN？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#TCP-%E7%9A%84%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B"><span class="nav-number">2.2.</span> <span class="nav-text">TCP 的四次挥手</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%9C%80%E5%90%8E%E8%BF%98%E8%A6%81%E7%AD%89%E5%BE%852MSL%EF%BC%9F"><span class="nav-number">2.2.1.</span> <span class="nav-text">为什么客户端最后还要等待2MSL？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BB%BA%E7%AB%8B%E8%BF%9E%E6%8E%A5%E6%98%AF%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%EF%BC%8C%E5%85%B3%E9%97%AD%E8%BF%9E%E6%8E%A5%E7%A1%AE%E6%98%AF%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%E5%91%A2%EF%BC%9F"><span class="nav-number">2.2.2.</span> <span class="nav-text">为什么建立连接是三次握手，关闭连接确是四次挥手呢？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E6%9E%9C%E5%B7%B2%E7%BB%8F%E5%BB%BA%E7%AB%8B%E4%BA%86%E8%BF%9E%E6%8E%A5%EF%BC%8C%E4%BD%86%E6%98%AF%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%AA%81%E7%84%B6%E5%87%BA%E7%8E%B0%E6%95%85%E9%9A%9C%E4%BA%86%E6%80%8E%E4%B9%88%E5%8A%9E"><span class="nav-number">2.2.3.</span> <span class="nav-text">如果已经建立了连接，但是客户端突然出现故障了怎么办</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#TCP-%E5%92%8C-UDP-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">3.</span> <span class="nav-text">TCP 和 UDP 的区别</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#TCP-%E5%8D%8F%E8%AE%AE%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93"><span class="nav-number">4.</span> <span class="nav-text">TCP 协议如何保证可靠传输</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#ARQ-%E5%8D%8F%E8%AE%AE"><span class="nav-number">4.1.</span> <span class="nav-text">ARQ 协议</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%81%9C%E6%AD%A2%E7%AD%89%E5%BE%85-ARQ-%E5%8D%8F%E8%AE%AE"><span class="nav-number">4.1.1.</span> <span class="nav-text">停止等待 ARQ 协议</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9E%E7%BB%AD-ARQ-%E5%8D%8F%E8%AE%AE"><span class="nav-number">4.1.2.</span> <span class="nav-text">连续 ARQ 协议</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%87%8D%E4%BC%A0%E7%B1%BB%E5%9E%8B"><span class="nav-number">4.1.3.</span> <span class="nav-text">重传类型</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E5%92%8C%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6"><span class="nav-number">4.2.</span> <span class="nav-text">滑动窗口和流量控制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AA%97%E5%8F%A3%E7%9A%84%E5%A4%A7%E5%B0%8F"><span class="nav-number">4.2.1.</span> <span class="nav-text">窗口的大小</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8E%A5%E6%94%B6%E7%AA%97%E5%8F%A3%E5%92%8C%E5%8F%91%E9%80%81%E7%AA%97%E5%8F%A3%E7%9A%84%E5%A4%A7%E5%B0%8F%E6%98%AF%E7%9B%B8%E7%AD%89%E7%9A%84%E5%90%97%EF%BC%9F"><span class="nav-number">4.2.2.</span> <span class="nav-text">接收窗口和发送窗口的大小是相等的吗？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%EF%BC%9F"><span class="nav-number">4.2.3.</span> <span class="nav-text">什么是流量控制？</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6"><span class="nav-number">5.</span> <span class="nav-text">拥塞控制</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%8B%A5%E5%A1%9E%E7%AA%97%E5%8F%A3"><span class="nav-number">5.1.</span> <span class="nav-text">什么是拥塞窗口</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E6%9C%89%E5%93%AA%E4%BA%9B%E6%8E%A7%E5%88%B6%E7%AE%97%E6%B3%95%EF%BC%9F"><span class="nav-number">5.2.</span> <span class="nav-text">拥塞控制有哪些控制算法？</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%85%A2%E5%BC%80%E5%A7%8B"><span class="nav-number">5.2.1.</span> <span class="nav-text">慢开始</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8B%A5%E5%A1%9E%E9%81%BF%E5%85%8D"><span class="nav-number">5.2.2.</span> <span class="nav-text">拥塞避免</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BF%AB%E9%87%8D%E4%BC%A0%E4%B8%8E%E5%BF%AB%E6%81%A2%E5%A4%8D"><span class="nav-number">5.2.3.</span> <span class="nav-text">快重传与快恢复</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#DNS-%E5%8E%9F%E7%90%86"><span class="nav-number">6.</span> <span class="nav-text">DNS 原理</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9C%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E8%BE%93%E5%85%A5-url-%E5%9C%B0%E5%9D%80-gt-gt-%E6%98%BE%E7%A4%BA%E4%B8%BB%E9%A1%B5%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="nav-number">7.</span> <span class="nav-text">在浏览器中输入 url 地址 -&gt;&gt; 显示主页的过程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BE%93%E5%85%A5%E5%9C%B0%E5%9D%80"><span class="nav-number">7.1.</span> <span class="nav-text">输入地址</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E6%9F%A5%E6%89%BE%E5%9F%9F%E5%90%8D%E7%9A%84-IP-%E5%9C%B0%E5%9D%80"><span class="nav-number">7.2.</span> <span class="nav-text">浏览器查找域名的 IP 地址</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E5%90%91-web-%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%8F%91%E9%80%81%E4%B8%80%E4%B8%AA-HTTP-%E8%AF%B7%E6%B1%82"><span class="nav-number">7.3.</span> <span class="nav-text">浏览器向 web 服务器发送一个 HTTP 请求</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E6%B0%B8%E4%B9%85%E9%87%8D%E5%AE%9A%E5%90%91%E5%93%8D%E5%BA%94"><span class="nav-number">7.4.</span> <span class="nav-text">服务器的永久重定向响应</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%A4%84%E7%90%86%E8%AF%B7%E6%B1%82"><span class="nav-number">7.5.</span> <span class="nav-text">服务器处理请求</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%BF%94%E5%9B%9E%E4%B8%80%E4%B8%AA-HTTP-%E5%93%8D%E5%BA%94"><span class="nav-number">7.6.</span> <span class="nav-text">服务器返回一个 HTTP 响应</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E6%98%BE%E7%A4%BA-HTML"><span class="nav-number">7.7.</span> <span class="nav-text">浏览器显示 HTML</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8F%91%E9%80%81%E8%AF%B7%E6%B1%82%E8%8E%B7%E5%8F%96%E5%B5%8C%E5%85%A5%E5%9C%A8-HTML-%E4%B8%AD%E7%9A%84%E8%B5%84%E6%BA%90"><span class="nav-number">7.8.</span> <span class="nav-text">浏览器发送请求获取嵌入在 HTML 中的资源</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B4%E4%B8%AA%E8%BF%87%E7%A8%8B%E4%BD%BF%E7%94%A8%E5%88%B0%E7%9A%84%E5%8D%8F%E8%AE%AE"><span class="nav-number">7.9.</span> <span class="nav-text">整个过程使用到的协议</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#HTTP-%E7%9A%84%E7%8A%B6%E6%80%81%E7%A0%81"><span class="nav-number">8.</span> <span class="nav-text">HTTP 的状态码</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#HTTP-%E7%9A%84%E9%95%BF%E8%BF%9E%E6%8E%A5%E4%B8%8E%E7%9F%AD%E8%BF%9E%E6%8E%A5"><span class="nav-number">9.</span> <span class="nav-text">HTTP 的长连接与短连接</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#HTTP-%E6%98%AF%E4%B8%8D%E4%BF%9D%E5%AD%98%E7%8A%B6%E6%80%81%E7%9A%84%E5%8D%8F%E8%AE%AE-%E9%82%A3%E5%BA%94%E8%AF%A5%E5%A6%82%E4%BD%95%E4%BF%9D%E5%AD%98%E7%94%A8%E6%88%B7%E7%8A%B6%E6%80%81"><span class="nav-number">10.</span> <span class="nav-text">HTTP 是不保存状态的协议, 那应该如何保存用户状态?</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Cookie-%E7%9A%84%E4%BD%9C%E7%94%A8%E6%98%AF%E4%BB%80%E4%B9%88-%E5%92%8C-Session-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">11.</span> <span class="nav-text">Cookie 的作用是什么? 和 Session 有什么区别？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#HTTP-1-0-%E5%92%8C-HTTP-1-1-%E7%9A%84%E4%B8%BB%E8%A6%81%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">12.</span> <span class="nav-text">HTTP 1.0 和 HTTP 1.1 的主要区别是什么？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#URI-%E4%B8%8E-URL-%E7%9A%84%E4%B8%BB%E8%A6%81%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">13.</span> <span class="nav-text">URI 与 URL 的主要区别是什么？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#HTTP-%E4%B8%8E-HTTPS-%E7%9A%84%E4%B8%BB%E8%A6%81%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">14.</span> <span class="nav-text">HTTP 与 HTTPS 的主要区别是什么？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#GET-%E5%92%8C-POST-%E7%9A%84%E5%8C%BA%E5%88%AB%E3%80%81HTTP%E8%AF%B7%E6%B1%82%E7%9A%84%E6%96%B9%E6%B3%95"><span class="nav-number">15.</span> <span class="nav-text">GET 和 POST 的区别、HTTP请求的方法</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8C%BA%E5%88%AB"><span class="nav-number">15.1.</span> <span class="nav-text">区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AF%B7%E6%B1%82%E6%96%B9%E6%B3%95"><span class="nav-number">15.2.</span> <span class="nav-text">请求方法</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%9C%89%E5%93%AA%E4%BA%9B%E6%9C%89%E7%8A%B6%E6%80%81%E5%8D%8F%E8%AE%AE"><span class="nav-number">16.</span> <span class="nav-text">有哪些有状态协议</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#HTTP-1-0-1-1-2-0-3-0"><span class="nav-number">17.</span> <span class="nav-text">HTTP 1.0&#x2F;1.1&#x2F;2.0&#x2F;3.0</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#HTTP-1-0"><span class="nav-number">17.1.</span> <span class="nav-text">HTTP 1.0</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HTTP-1-1"><span class="nav-number">17.2.</span> <span class="nav-text">HTTP 1.1</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%95%BF%E8%BF%9E%E6%8E%A5"><span class="nav-number">17.2.1.</span> <span class="nav-text">长连接</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%A1%E9%81%93%E5%8C%96"><span class="nav-number">17.2.2.</span> <span class="nav-text">管道化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%93%E5%AD%98%E5%A4%84%E7%90%86"><span class="nav-number">17.2.3.</span> <span class="nav-text">缓存处理</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HTTP-2-0"><span class="nav-number">17.3.</span> <span class="nav-text">HTTP 2.0</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%88%86%E5%B8%A7"><span class="nav-number">17.3.1.</span> <span class="nav-text">二进制分帧</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8-%E8%BF%9E%E6%8E%A5%E5%85%B1%E4%BA%AB"><span class="nav-number">17.3.2.</span> <span class="nav-text">多路复用 &#x2F; 连接共享</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%B4%E9%83%A8%E5%8E%8B%E7%BC%A9"><span class="nav-number">17.3.3.</span> <span class="nav-text">头部压缩</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AF%B7%E6%B1%82%E4%BC%98%E5%85%88%E7%BA%A7"><span class="nav-number">17.3.4.</span> <span class="nav-text">请求优先级</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%8E%A8%E9%80%81"><span class="nav-number">17.3.5.</span> <span class="nav-text">服务器推送</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HTTP-3-0"><span class="nav-number">17.4.</span> <span class="nav-text">HTTP 3.0</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#0-RTT"><span class="nav-number">17.4.1.</span> <span class="nav-text">0-RTT</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8"><span class="nav-number">17.4.2.</span> <span class="nav-text">多路复用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9B%B4%E5%A5%BD%E7%9A%84%E7%A7%BB%E5%8A%A8%E7%AB%AF%E8%A1%A8%E7%8E%B0"><span class="nav-number">17.4.3.</span> <span class="nav-text">更好的移动端表现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8A%A0%E5%AF%86%E8%AE%A4%E8%AF%81%E7%9A%84%E6%A0%B9%E6%96%87"><span class="nav-number">17.4.4.</span> <span class="nav-text">加密认证的根文</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%91%E5%89%8D%E7%BA%A0%E9%94%99%E6%9C%BA%E5%88%B6"><span class="nav-number">17.4.5.</span> <span class="nav-text">向前纠错机制</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%E7%AD%89%E5%BE%85-2-MSL"><span class="nav-number">18.</span> <span class="nav-text">为什么四次挥手等待 2 MSL</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#301-%E5%92%8C-302-%E7%8A%B6%E6%80%81%E7%A0%81%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">19.</span> <span class="nav-text">301 和 302 状态码的区别</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#HTTP%E3%80%81TCP%E3%80%81IP-%E4%B8%89%E7%A7%8D%E5%8D%8F%E8%AE%AE%E4%B8%AD%EF%BC%8C%E6%8E%A5%E6%94%B6%E7%AB%AF%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E5%B7%B2%E6%8E%A5%E6%94%B6%E5%AE%8C%E5%AF%B9%E7%AB%AF%E5%8F%91%E9%80%81%E6%9D%A5%E7%9A%84%E6%95%B0%E6%8D%AE%EF%BC%9F"><span class="nav-number">20.</span> <span class="nav-text">HTTP、TCP、IP 三种协议中，接收端如何判断已接收完对端发送来的数据？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#HTTP-%E7%8A%B6%E6%80%81%E7%A0%81%E6%95%85%E9%9A%9C%E6%8E%92%E9%99%A4"><span class="nav-number">21.</span> <span class="nav-text">HTTP 状态码故障排除</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#5XX"><span class="nav-number">21.1.</span> <span class="nav-text">5XX</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#500"><span class="nav-number">21.1.1.</span> <span class="nav-text">500</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#501"><span class="nav-number">21.1.2.</span> <span class="nav-text">501</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#502"><span class="nav-number">21.1.3.</span> <span class="nav-text">502</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#503"><span class="nav-number">21.1.4.</span> <span class="nav-text">503</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#504"><span class="nav-number">21.1.5.</span> <span class="nav-text">504</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4XX"><span class="nav-number">21.2.</span> <span class="nav-text">4XX</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#400"><span class="nav-number">21.2.1.</span> <span class="nav-text">400</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#401"><span class="nav-number">21.2.2.</span> <span class="nav-text">401</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#403"><span class="nav-number">21.2.3.</span> <span class="nav-text">403</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#404"><span class="nav-number">21.2.4.</span> <span class="nav-text">404</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3XX"><span class="nav-number">21.3.</span> <span class="nav-text">3XX</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#300"><span class="nav-number">21.3.1.</span> <span class="nav-text">300</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#301-amp-302"><span class="nav-number">21.3.2.</span> <span class="nav-text">301 &amp; 302</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#HTTP-header-%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="nav-number">22.</span> <span class="nav-text">HTTP header 有哪些？</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Request-%E7%9A%84%E5%A4%B4%E9%83%A8%E4%BF%A1%E6%81%AF"><span class="nav-number">22.1.</span> <span class="nav-text">Request 的头部信息</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Response-%E7%9A%84%E5%A4%B4%E9%83%A8%E4%BF%A1%E6%81%AF"><span class="nav-number">22.2.</span> <span class="nav-text">Response 的头部信息</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Http-%E4%B8%8E-TCP-%E4%B8%AD-keep-alive-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">23.</span> <span class="nav-text">Http 与 TCP 中 keep-alive 的区别</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#TCP-%E7%9A%84%E7%B2%98%E5%8C%85%E4%B8%8E%E5%8D%8A%E5%8C%85%E9%97%AE%E9%A2%98"><span class="nav-number">24.</span> <span class="nav-text">TCP 的粘包与半包问题</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%B2%98%E5%8C%85%E4%B8%8E%E5%8D%8A%E5%8C%85"><span class="nav-number">24.1.</span> <span class="nav-text">什么是粘包与半包</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8E%9F%E5%9B%A0"><span class="nav-number">24.2.</span> <span class="nav-text">原因</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B2%98%E5%8C%85"><span class="nav-number">24.2.1.</span> <span class="nav-text">粘包</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8D%8A%E5%8C%85"><span class="nav-number">24.2.2.</span> <span class="nav-text">半包</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%A7%A3%E5%86%B3%E7%B2%98%E5%8C%85%E5%8D%8A%E5%8C%85%E9%97%AE%E9%A2%98"><span class="nav-number">24.3.</span> <span class="nav-text">解决粘包半包问题</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Zodiacal</p>
  <div class="site-description" itemprop="description">引出魔鬼的一种试炼</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">47</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">17</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">44</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Zodiacal</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">482k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">7:18</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
