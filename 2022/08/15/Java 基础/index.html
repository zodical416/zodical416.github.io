<!DOCTYPE html>
<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Noto Serif SC:300,300italic,400,400italic,700,700italic|Lobster Two:300,300italic,400,400italic,700,700italic|EB Garamond:300,300italic,400,400italic,700,700italic|Source Code Pro:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"zodical416.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":false,"style":"mac"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="忧伤浸透她的脸">
<meta property="og:type" content="article">
<meta property="og:title" content="Java 基础">
<meta property="og:url" content="https://zodical416.github.io/2022/08/15/Java%20%E5%9F%BA%E7%A1%80/index.html">
<meta property="og:site_name" content="Zodiacal">
<meta property="og:description" content="忧伤浸透她的脸">
<meta property="og:locale">
<meta property="og:image" content="https://raw.githubusercontent.com/zodical416/picto/master/1663492662252.png">
<meta property="og:image" content="https://raw.githubusercontent.com/zodical416/picto/master/20220917152320.png">
<meta property="og:image" content="https://raw.githubusercontent.com/zodical416/picto/master/1663493293512.png">
<meta property="article:published_time" content="2022-08-15T12:28:53.639Z">
<meta property="article:modified_time" content="2022-09-18T10:11:57.861Z">
<meta property="article:author" content="Zodiacal">
<meta property="article:tag" content="Java 基础">
<meta property="article:tag" content="面试">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://raw.githubusercontent.com/zodical416/picto/master/1663492662252.png">

<link rel="canonical" href="https://zodical416.github.io/2022/08/15/Java%20%E5%9F%BA%E7%A1%80/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-Hans'
  };
</script>

  <title>Java 基础 | Zodiacal</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Zodiacal</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://zodical416.github.io/2022/08/15/Java%20%E5%9F%BA%E7%A1%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zodiacal">
      <meta itemprop="description" content="引出魔鬼的一种试炼">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zodiacal">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Java 基础
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-08-15 20:28:53" itemprop="dateCreated datePublished" datetime="2022-08-15T20:28:53+08:00">2022-08-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-09-18 18:11:57" itemprop="dateModified" datetime="2022-09-18T18:11:57+08:00">2022-09-18</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java-%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index"><span itemprop="name">Java 基础</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>17k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>15 分钟</span>
            </span>
            <div class="post-description">忧伤浸透她的脸</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h1><p><img src="https://raw.githubusercontent.com/zodical416/picto/master/1663492662252.png"></p>
<h1 id="和-equals-的区别"><a href="#和-equals-的区别" class="headerlink" title="== 和 equals 的区别"></a>== 和 equals 的区别</h1><p>== 对于基本类型和引用类型的作用效果是不同的：</p>
<ul>
<li>对于基本数据类型来说，== 比较的是值。</li>
<li>对于引用数据类型来说，== 比较的是对象的内存地址。</li>
</ul>
<p>equals() 作用不能用于判断基本数据类型的变量，只能用来判断两个对象是否相等。equals()方法存在于Object类中，而Object类是所有类的直接或间接父类。</p>
<p>equals() 方法存在两种使用情况：</p>
<ul>
<li>类没有覆盖 equals()方法 ：通过equals()比较该类的两个对象时，等价于通过“==”比较这两个对象，使用的默认是 Object类equals()方法。</li>
<li>类覆盖了 equals()方法 ：一般我们都覆盖 equals()方法来比较两个对象中的属性是否相等；若它们的属性相等，则返回 true(即，认为这两个对象相等)。</li>
</ul>
<p>例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">String a = <span class="keyword">new</span> String(<span class="string">&quot;ab&quot;</span>); <span class="comment">// a 为一个引用</span></span><br><span class="line">String b = <span class="keyword">new</span> String(<span class="string">&quot;ab&quot;</span>); <span class="comment">// b为另一个引用,对象的内容一样</span></span><br><span class="line">String aa = <span class="string">&quot;ab&quot;</span>; <span class="comment">// 放在常量池中</span></span><br><span class="line">String bb = <span class="string">&quot;ab&quot;</span>; <span class="comment">// 从常量池中查找</span></span><br><span class="line">System.out.println(aa == bb);<span class="comment">// true</span></span><br><span class="line">System.out.println(a == b);<span class="comment">// false</span></span><br><span class="line">System.out.println(a.equals(b));<span class="comment">// true</span></span><br><span class="line">System.out.println(<span class="number">42</span> == <span class="number">42.0</span>);<span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>String 中的 equals 方法是被重写过的，因为 Object 的 equals 方法是比较的对象的内存地址，而 String 的 equals 方法比较的是对象的值。</p>
<p>当创建 String 类型的对象时，虚拟机会在常量池中查找有没有已经存在的值和要创建的值相同的对象，如果有就把它赋给当前引用。如果没有就在常量池中重新创建一个 String 对象。</p>
<p>String 类中的 equals()方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object anObject)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> == anObject) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (anObject <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">        String anotherString = (String)anObject;</span><br><span class="line">        <span class="keyword">int</span> n = value.length;</span><br><span class="line">        <span class="keyword">if</span> (n == anotherString.value.length) &#123;</span><br><span class="line">            <span class="keyword">char</span> v1[] = value;</span><br><span class="line">            <span class="keyword">char</span> v2[] = anotherString.value;</span><br><span class="line">            <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (n-- != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (v1[i] != v2[i])</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="为什么重写-equals-时必须重写-hashCode-方法？"><a href="#为什么重写-equals-时必须重写-hashCode-方法？" class="headerlink" title="为什么重写 equals() 时必须重写 hashCode() 方法？"></a>为什么重写 equals() 时必须重写 hashCode() 方法？</h1><p>hashCode() 的作用是获取哈希码（int 整数），也称为散列码。这个哈希码的作用是确定该对象在哈希表中的索引位置。hashCode()定义在 JDK 的 Object 类中，这就意味着 Java 中的任何类都包含有 hashCode() 函数。另外需要注意的是： Object 的 hashCode() 方法是本地方法，也就是用 C 语言或 C++ 实现的，该方法通常用来将对象的内存地址转换为整数之后返回。</p>
<p>当把对象加入 HashSet 时，HashSet 会先计算对象的 hashcode 值来判断对象加入的位置，同时也会与其他已经加入的对象的 hashcode 值作比较，如果没有相符的 hashcode，HashSet 会假设对象没有重复出现。但是如果发现有相同 hashcode 值的对象，这时会调用 equals() 方法来检查 hashcode 相等的对象是否真的相同。如果两者相同，HashSet 就不会让其加入操作成功。如果不同的话，就会重新散列到其他位置。这样我们就大大减少了 equals 的次数，相应就大大提高了执行速度。</p>
<p>因此，重写 equals 方法时重写 hashCode 方法的目的就是，如果 equals 方法判断两个对象是相等的，那这两个对象的 hashCode 值也要相等，如果不重写 hashCode 方法，那么所得的两个方法就不相等了。</p>
<h1 id="静态变量与非静态变量（归属、存储、生命周期、访问方式）"><a href="#静态变量与非静态变量（归属、存储、生命周期、访问方式）" class="headerlink" title="静态变量与非静态变量（归属、存储、生命周期、访问方式）"></a>静态变量与非静态变量（归属、存储、生命周期、访问方式）</h1><p>静态变量属于类，存储在 JVM 方法区中的静态区里，随着类加载而被加载，随着类消失而消失，访问方式是 类名.属性名或者类名.getter 和 setter 方法</p>
<p>非静态变量分为全局变量与局部变量两种：全局变量属于对象，存储于堆空间的对象空间里，随着对象的产生而产生，访问方式是对象名.属性名或者对象名.getter和setter方法，或者直接使用。局部变量属于方法，存储于栈空间的方法中，将会随着方法的调用而产生，能够直接用变量名调用。</p>
<h1 id="static-关键字"><a href="#static-关键字" class="headerlink" title="static 关键字"></a>static 关键字</h1><h2 id="static-方法"><a href="#static-方法" class="headerlink" title="static 方法"></a>static 方法</h2><p>也就是静态方法，不依赖于对象就能够完成访问，只要类被加载了，就可以通过类名进行访问。但是在静态方法中是不能访问类的非静态成员变量与非静态的成员方法的。最常见的 static 方法就是 main 方法，这是因为程序在执行 main 方法时没有创建任何对象，只能通过类名访问。</p>
<h2 id="static-变量"><a href="#static-变量" class="headerlink" title="static 变量"></a>static 变量</h2><p>也就是静态变量，静态变量能够被所有的对象共享，在内存中只有一份，并且会在类初始化的时候完成初始化。而非静态变量则是对象所拥有的，在创建对象的时候被初始化，因此它会存在多个副本，各个对象拥有的副本互不影响。</p>
<p>静态变量初始化顺序为定义的顺序</p>
<h2 id="static-代码块"><a href="#static-代码块" class="headerlink" title="static 代码块"></a>static 代码块</h2><p>静态代码块常用于提升性能，在类第一次被加载的时候会按照顺序执行每一个 static 代码块，并且只执行一次。很多时候都是将只需要执行一次的初始化操作放入 static 代码块中，从而确保执行一次，来提升性能。</p>
<h1 id="Java-三大特性"><a href="#Java-三大特性" class="headerlink" title="Java 三大特性"></a>Java 三大特性</h1><h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p>定义就是相同的事物，调用相同的方法，哪怕参数相同，但是所表现的行为是不同的。多态的好处在于消除了类之间的耦合关系，使得程序更加容易实现扩展。</p>
<p>实现多态的必要条件包括：继承、重写与向上转型。继承是指必须存在有继承关系的子类与父类；重写是指子类需要对父类中的某些方法进行重新定义；向上转型是指在多态中需要将子类的引用赋给父类对象，只有这样该引用才能够具备技能调用父类的方法和子类的方法。</p>
<p>多态的特点包括：可替换性、可扩充性、接口性、灵活性、简化性</p>
<p>多态的实现方式有：重写、接口、抽象类与抽象方法</p>
<h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><p>封装是指把一个对象的状态信息（也就是属性）隐藏在对象内部，不允许外部对象直接访问对象的内部信息。但是可以提供一些可以被外界访问的方法来操作属性。封装的优点主要有：良好的封装能够减少耦合；类内部的结构可以自由修改；可以对成员变量进行更精确的控制；隐藏信息，实现细节。实现 Java 封装，可以设置属性的可见性来限制访问，一般是设置为 private，并通过提供对外的公共方法，一般是一对取赋值方法，来完成对私有属性的访问</p>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>不同类型的对象，相互之间经常有一定数量的共同点，同时，每一个对象还定义了额外的特性使得他们与众不同。继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。通过使用继承，可以快速地创建新的类，可以提高代码的重用，程序的可维护性，节省大量创建新类的时间 ，提高我们的开发效率。</p>
<p>特性：子类拥有父类非 private 的属性、方法；子类可以拥有自己的属性和方法，即子类可以对父类进行扩展；子类可以用自己的方式实现父类的方法；提高了类之间的耦合性提高了类之间的耦合性。</p>
<h1 id="子类不能重写构造方法，但是构造方能可以被重载"><a href="#子类不能重写构造方法，但是构造方能可以被重载" class="headerlink" title="子类不能重写构造方法，但是构造方能可以被重载"></a>子类不能重写构造方法，但是构造方能可以被重载</h1><p>因为构造器是不能被继承的，每个类的类名都不相同，构造器的名称又与类名相同，因此没法继承。由于构造器不能被继承，因此就不能重写构造方法。</p>
<h1 id="重写与重载的区别"><a href="#重写与重载的区别" class="headerlink" title="重写与重载的区别"></a>重写与重载的区别</h1><p>重写是子类对父类允许访问的方法的具体实现进行重新编写，返回值与形参都不能改变，也就是所谓的外壳不变，核心重写。重写的好处在于子类可以根据需要定义特定于自己的行为，但是重写不能抛出新的检查异常或者比被重写方法申明更加宽泛的异常。</p>
<p>重载是指在同一个类里面，方法名字相同而参数不同，返回类型可以相同也可以不同。每个重载的方法都必须有一个独一无二的参数类型列表。最常见的重载就是构造器的重载。</p>
<h2 id="重写规则"><a href="#重写规则" class="headerlink" title="重写规则"></a>重写规则</h2><ul>
<li>参数列表与被重写方法的参数列表必须完全相同</li>
<li>返回类型可以不相同，但是必须是父类返回值的派生类</li>
<li>访问权限不能比父类更低，如果父类为 public，那么子类不能为 protected</li>
<li>final 方法不能重写、static 方法不能重写，但是可以再次声明</li>
<li>如果父类和子类在同一个包中，那么子类能够重写父类的所有方法，除了声明为 private 和 final 的方法；如果不在一个包中，那么只能重写声明为 public 和 protected 的非 final 方法</li>
<li>构造方法不能被重写</li>
</ul>
<h2 id="重载规则"><a href="#重载规则" class="headerlink" title="重载规则"></a>重载规则</h2><ul>
<li>被重载的方法必须改变参数列表、可以改变返回类型、可以改变访问修饰符、可以声明新的或更广的异常</li>
</ul>
<h1 id="Java-中创建对象的方法"><a href="#Java-中创建对象的方法" class="headerlink" title="Java 中创建对象的方法"></a>Java 中创建对象的方法</h1><ul>
<li>new 关键字创建对象，需要用到构造器</li>
<li>通过反射机制创建对象，调用 Class 类或 Constructor 类的 newInstance() 方法，需要构造器</li>
<li>通过 Object 类的 clone 方法，需要实现 cloneable 接口，重写 clone 方法，无论何时我们调用一个对象的clone方法，JVM就会创建一个新的对象，将前面对象的内容全部拷贝进去。不需要使用构造器</li>
<li>使用反序列化：通过 ObjectInputStream 的 readObject() 方法反序列化类当我们序列化和反序列化一个对象，JVM会给我们创建一个单独的对象。为了反序列化一个对象，我们需要让我们的类实现Serializable接口。在反序列化时，JVM创建对象并不会调用任何构造函数。</li>
</ul>
<h1 id="值传递：Java-中没有引用传递"><a href="#值传递：Java-中没有引用传递" class="headerlink" title="值传递：Java 中没有引用传递"></a>值传递：Java 中没有引用传递</h1><p>值传递指的是在调用函数时，将实际参数复制一份传到函数中，这样在函数中对参数进行一系列的操作修改，并不会影响到实际的参数</p>
<p>引用传递指的是在调用函数时，传递到函数中的是实际参数的地址，那么这样在对参数进行一系列的修改时，会对实际参数造成影响。</p>
<p>Java 中仅有值传递，值传递和引用传递的主要区别在于是不是在传递时进行了复制，在判断实参内容有没有受影响的时候，要看传的的是什么，如果你传递的是个地址，那么就看这个地址的变化会不会有影响，而不是看地址指向的对象的变化。</p>
<p>对于对象参数，Java 值传递的内容是对于对象的引用，因此有时候看上去像是引用传递</p>
<h1 id="String-和-StringBuffer-的区别，创建对象时使用-String-赋值和用-new-创建是否一样？"><a href="#String-和-StringBuffer-的区别，创建对象时使用-String-赋值和用-new-创建是否一样？" class="headerlink" title="String 和 StringBuffer 的区别，创建对象时使用 String 赋值和用 new 创建是否一样？"></a>String 和 StringBuffer 的区别，创建对象时使用 String 赋值和用 new 创建是否一样？</h1><p>String str = “abc”; 可能创建一个或者不创建对象，如果”abc”在字符串池中不存在，会在java字符串池中创建一个String对象（”abc”），然后 str 指向这个内存地址，无论以后用这种方式创建多少个值为”abc”的字符串对象，始终只有一个内存地址被分配。== 判断的是对象的内存地址，而equals判断的是对象内容。</p>
<p>但是如果用 new 关键字创建对象，那么至少会创建一个对象，也有可能创建两个。因为用到 new 关键字，肯定会在堆中创建一个 String 对象，如果字符池中已经存在 ”abc”，则不会在字符串池中创建一个String对象，如果不存在，则会在字符串常量池中也创建一个对象。</p>
<p>String 是字符串常量，存放字符的数组被声明为了 final 类型，只能被赋值一次，不可再修改。这样在每次对 String 类型进行改变时都会生成一个新的对象，无用对象变多之后会显著影响系统性能。</p>
<p>StringBuffer 会对对象本身进行操作，不需要生成新的对象，同时 StringBuffer 是线程安全的。线程不安全的 StringBuffer 就是 StringBuilder，其因为不用考虑线程安全问题，因此速度更快。</p>
<h1 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h1><ul>
<li>default 默认，在同一包内可见，不使用任何修饰符。使用对象：类、接口、变量、方法。</li>
<li>private，同一类内可见，使用对象：变量、方法。 <strong>注意：不能修饰类（外部类）</strong></li>
<li>public，对所有类可见，使用对象：类、接口、变量、方法</li>
<li>protected，对同一包内的类和所有子类可见。使用对象：变量、方法。 <strong>注意：不能修饰类（外部类）</strong>。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/zodical416/picto/master/20220917152320.png"></p>
<h1 id="接口和抽象类"><a href="#接口和抽象类" class="headerlink" title="接口和抽象类"></a>接口和抽象类</h1><h2 id="区别与共同点"><a href="#区别与共同点" class="headerlink" title="区别与共同点"></a>区别与共同点</h2><p>共同点：</p>
<ul>
<li>都不能被实例化</li>
<li>都可以包含抽象方法</li>
<li>都可以有默认实现的方法（Java 8 中可以用 default 关键字在接口中定义默认方法）</li>
</ul>
<p>区别：</p>
<ul>
<li>接口主要用于对类的行为进行约束，实现了一个接口，那么就具备了这个接口所对应的行为，抽象类则主要是用于代码的复用，强调一个所属的关系</li>
<li>一个类只能继承一个类，但是可以继承多个接口</li>
<li>接口中的成员变量只能是 public static final 类型的，不能被修改并且必须有初始值，而抽象类的成员变量默认是 default，可以被重新定义，也可以重新赋值</li>
</ul>
<h2 id="什么时候用抽象类，什么时候用接口"><a href="#什么时候用抽象类，什么时候用接口" class="headerlink" title="什么时候用抽象类，什么时候用接口"></a>什么时候用抽象类，什么时候用接口</h2><p>抽象类：使用继承概念、定义非 public 成员时、未来需要添加新方法时，因为当我们在接口内添加新的方法时，所有实现该接口的类都需要添加新的方法、想提供公共的已实现的功能时，因为接口不为任何成员提供任何实现</p>
<p>接口：API 在短期内都不会发生修改时、存在多重继承关系时、设计小巧简单的功能时、两个完全不同的对象需要实现差不多的功能时，因为抽象类主要作用于紧密联系的对象之间。</p>
<h2 id="抽象类能用-final-修饰吗"><a href="#抽象类能用-final-修饰吗" class="headerlink" title="抽象类能用 final 修饰吗"></a>抽象类能用 final 修饰吗</h2><p>抽象类本身不能被 final 修饰，因为抽象类必须被继承，而被 final 修饰的类就不能被继承了。但是抽象类里面的属性与方法是可以用 final 进行修饰的</p>
<h2 id="抽象类中可不可以有-private-变量与方法"><a href="#抽象类中可不可以有-private-变量与方法" class="headerlink" title="抽象类中可不可以有 private 变量与方法"></a>抽象类中可不可以有 private 变量与方法</h2><p>都可以有，因为在抽象类中可以有具体的方法实现，在这些具体的方法实现中可以自行定义私有变量与方法</p>
<p>同时在 Java 9 中，接口也能够定义私有方法，但是不能定义私有属性</p>
<h1 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h1><p>在 Java 环境中，通过反射可以在运行时获得类型信息，并且能够对类和对象的内部属性进行操作。通过反射可以获取程序中每一个类型与成员变量的信息，哪怕对象类型在编译期是未知的，依然能够直接创建对象并调用其属性。</p>
<p>换言之，Java可以加载一个运行时才得知名称的class，获得其完整结构。</p>
<h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><p>Java 反射框架提供的功能有：</p>
<ol>
<li>运行时判断任意一个对象所属的类</li>
<li>在运行时构造任意一个类的对象</li>
<li>在运行时判断任意一个类所具有的成员变量与方法</li>
<li>在运行时调用任意一个对象的方法</li>
</ol>
<h2 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h2><p>实际上在使用 IDE 时，当我们输入一个对象，并向要调用它的属性与方法时，在我们输入 “.” 后，IDE 能自动列出对应的属性与方法，这个过程就用到了反射</p>
<p>除此之外，在开发各种通用框架，例如最常用的 Spring，都用到了反射。比方说 Spring 是配置化的，需要根据 xml 文件配置 Bean，为了保证框架的通用性，需要根据配置文件加载不同的对象或者类，调用不同的方法，这个时候就需要用到反射，从而在运行时动态加载所需要的对象。</p>
<h2 id="运用"><a href="#运用" class="headerlink" title="运用"></a>运用</h2><ol>
<li>获取 Class 对象：使用 Class 类的 forName 方法；直接获取对象的 Class 类，如 Class&lt;?&gt; klass = int.class;；调用 getClass 方法</li>
<li>判断是否为某个类的实例：调用 isInstance 方法</li>
<li>创建实例：newInstance 方法；先通过Class对象获取指定的Constructor对象，再调用Constructor对象的newInstance()方法来创建实例</li>
<li>获取某个Class对象的方法集合：getDeclaredMethods 返回类或接口声明的所有方法，包括公共、保护、默认（包）访问和私有方法，但不包括继承的方法；getMethods 方法返回某个类的所有公用（public）方法，包括其继承类的公用方法</li>
<li>获取类的成员变量：getFiled 访问公有成员变量；getDeclaredField 访问所有已声明的成员变量</li>
<li>调用方法：获取方法后，可以用 invoke 调用方法</li>
</ol>
<h1 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h1><p>就是两个或以上的进程，在执行过程中产生的阻塞现象</p>
<h2 id="产生死锁的四个条件"><a href="#产生死锁的四个条件" class="headerlink" title="产生死锁的四个条件"></a>产生死锁的四个条件</h2><ul>
<li>互斥：一个资源每次只能被一个进程所使用</li>
<li>请求与保持：一个进程因请求资源而阻塞时，对已获得的资源保持不放</li>
<li>不剥夺：进程已获得的资源，在未使用完时，不能强行剥夺</li>
<li>循环等待：若干进程之间形成循环等待资源释放的关系</li>
</ul>
<h2 id="如何解决死锁？"><a href="#如何解决死锁？" class="headerlink" title="如何解决死锁？"></a>如何解决死锁？</h2><p>破坏死锁产生的四个条件即可</p>
<h3 id="破坏请求与保持条件"><a href="#破坏请求与保持条件" class="headerlink" title="破坏请求与保持条件"></a>破坏请求与保持条件</h3><ol>
<li>所有进程在开始运行之前，必须一次性申请其在整个运行过程中所需要的全部资源<br>优点：简单安全<br>缺点：降低了资源的利用率，造成资源浪费，使得进程经常发生饥饿现象</li>
<li>允许进程只获取运行初期所需要的资源便开始运行，在运行过程中逐步释放掉分配到的已经使用完毕的资源，然后再去请求新资源。这样能够提高资源利用率，减少饥饿问题</li>
</ol>
<h3 id="破坏不剥夺条件"><a href="#破坏不剥夺条件" class="headerlink" title="破坏不剥夺条件"></a>破坏不剥夺条件</h3><p>可以让一个已经持有了一些资源的进程在提出的新资源请求没有得到满足时，必须释放已经获取的资源。这种方法很复杂，并且代价很大，因为需要资源的反复申请与释放，这不仅会延长进程的周转周期，还会影响系统吞吐量</p>
<h3 id="破坏循环等待条件"><a href="#破坏循环等待条件" class="headerlink" title="破坏循环等待条件"></a>破坏循环等待条件</h3><p>将系统中的资源顺序编号，将紧缺稀少的资源采用较大的编号，申请时必须按照编号顺序进行，一个进程只有获得较小编号的资源才能申请较大编号的资源。</p>
<h2 id="银行家算法"><a href="#银行家算法" class="headerlink" title="银行家算法"></a>银行家算法</h2><p>通常采用银行家算法来避免死锁，银行家算法的基本思路是，创建可利用资源向量、最大需求矩阵、分配矩阵以及需求矩阵四个数据结构。</p>
<p>可利用资源向量用于表示系统中各种资源的剩余数量，由于系统中拥有的资源通常有多种，因此需要以数组来表示这些资源的种类，数组长度即为资源种类数。数组元素的初始值为系统中所配置的该类全部可用资源的大小，这个数值是随着这类资源的分配与回收动态变化的。</p>
<p>最大需求矩阵用于表示各个进程对各种资源的最大需求量，由于可能存在多个进程，因此需要用矩阵来表示每个进程对于每种资源的需求</p>
<p>分配矩阵用于表示已经分配给各个进程的各种资源的数目，与最大需求矩阵形式相同</p>
<p>需求矩阵用于表示进程仍然需要的资源数目，系统可能无法一次满足某个进程的最大需求，因此会先分配给进程一部分资源保证进程能够执行。因此最大需求减去已分配资源，就是进程仍然需要的资源数量了。</p>
<p>银行家算法就是通过对进程需求、占有和系统所拥有资源的实时统计，确保资源在分配给进程时不会造成死锁。</p>
<h2 id="死锁的代码"><a href="#死锁的代码" class="headerlink" title="死锁的代码"></a>死锁的代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeadLock</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String LOCK_1 = <span class="string">&quot;lock1&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String LOCK_2 = <span class="string">&quot;lock2&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread threadA = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                    <span class="keyword">synchronized</span> (DeadLock.LOCK_1) &#123;</span><br><span class="line">                        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 锁住 lock1&quot;</span>);</span><br><span class="line">                        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                        <span class="keyword">synchronized</span> (DeadLock.LOCK_2) &#123;</span><br><span class="line">                            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 锁住 lock2&quot;</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        Thread threadB = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                    <span class="keyword">synchronized</span> (DeadLock.LOCK_2) &#123;</span><br><span class="line">                        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 锁住 lock2&quot;</span>);</span><br><span class="line">                        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                        <span class="keyword">synchronized</span> (DeadLock.LOCK_1) &#123;</span><br><span class="line">                            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 锁住 lock1&quot;</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        threadA.start();</span><br><span class="line">        threadB.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个代码中启动了两个线程，在每个线程中都试图获得 Lock1 和 Lock2，A 线程先获取 Lock1 再获取 Lock2，B 线程先获取 Lock2 再获取 Lock1，这样就构成了循环等待条件，两个线程都等待对方先释放锁，从而形成死锁。要想解决死锁，只需要更改获取锁的顺序即可，就把线程 B 改成先获取 Lock1 再获取 Lock2</p>
<h1 id="Java-中自带的注解"><a href="#Java-中自带的注解" class="headerlink" title="Java 中自带的注解"></a>Java 中自带的注解</h1><p>@Override：标记方法为重写方法，@Deprecated：标记过时方法，@Repeatable - Java 8 开始支持，标识某注解可以在同一个声明上使用多次</p>
<h1 id="字符串拼接：StringBuilder-及其他"><a href="#字符串拼接：StringBuilder-及其他" class="headerlink" title="字符串拼接：StringBuilder 及其他"></a>字符串拼接：StringBuilder 及其他</h1><p>常用的字符串拼接方式：加号拼接、StringBuilder、StringBuffer。由于 StringBuffer 是线程安全的，因此效率不如 StringBuilder</p>
<p>“+”与StringBuilder差别不大，在采用加号进行拼接时，实际上是直接调用了 StringBuilder 来完成，但是在采用循环方式创建字符串时，每次加号拼接都会创建一个 StringBuilder 对象，因此最好采用 StringBuilder 来完成拼接</p>
<p>除此之外，java 还提供了专门用于 String 拼接的 concat 方法其实现了将一个字符串连接到另一个字符串后面，一次只能连接两个字符串</p>
<h1 id="Java-基本数据类型"><a href="#Java-基本数据类型" class="headerlink" title="Java 基本数据类型"></a>Java 基本数据类型</h1><p>byte、short、int、long、char、double、float、boolean</p>
<ul>
<li>Java 使用 long 类型时需要在数值后加上 L，否则将作为整形进行解析</li>
<li>八种基本数据类型都有对应的包装类：Byte、Short、Integer、Long、Character、Double、Float、Boolean</li>
<li>基本数据类型存储于 Java 虚拟机栈的局部变量表中，包装类型属于对象类型，存放于堆中。</li>
</ul>
<h1 id="Java-IO-流（字符流、字节流（二进制流））"><a href="#Java-IO-流（字符流、字节流（二进制流））" class="headerlink" title="Java IO 流（字符流、字节流（二进制流））"></a>Java IO 流（字符流、字节流（二进制流））</h1><p>Java IO 流一般分为两类：字符流与字节流，以“Reader”结尾都是字符流，操作的都是字符型的数据；以“Stream”结尾的都是字节流，操作的都是byte数据。</p>
<h2 id="字节流"><a href="#字节流" class="headerlink" title="字节流"></a>字节流</h2><p>InputStream 和 <a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=OutputStream&spm=1001.2101.3001.7020">OutputStream</a>为各种输入输出字节流的基类，所有字节流都继承这两个基类。对文件的字节流操作是 FileInputStream 和 FileOutputStream。DataInputStream 是数据输入流，它继承于FilterInputStream。DataOutputStream 是数据输出流，它继承于FilterOutputStream。二者配合使用，“允许应用程序以与机器无关方式从底层输入流中读写基本 Java 数据类型”。</p>
<p>BufferedInputStream是带缓冲区的输入流，它继承于FilterInputStream。默认缓冲区大小是8M，能够减少访问磁盘的次数，提高文件读取性能。</p>
<p>BufferedOutputStream是带缓冲区的输出流，它继承于FilterOutputStream，能够提高文件的写入效率。</p>
<p>它们提供的“缓冲功能”本质上是通过一个内部缓冲区数组实现的。例如，在新建某输入流对应的BufferedInputStream后，当我们通过read()读取输入流的数据时，BufferedInputStream会将该输入流的数据分批的填入到缓冲区中。每当缓冲区中的数据被读完之后，输入流会再次填充数据缓冲区；如此反复，直到我们读完输入流数据。</p>
<h2 id="字符流"><a href="#字符流" class="headerlink" title="字符流"></a>字符流</h2><p>InputStreamReader 和 OutputStreamWriter为各种输入输出字符流的基类，所有字符流都继承这两个基类。实际上，这两个类内部各自持有一个inputStream 和 outputStream对象，相当于是对inputStream 和 outputStream进行了包装，将输入字节流转换成字符流，便于读写操作。</p>
<p>FileReader 和 FileWriter分别继承自 inputStreamReader 和 outputStreamWriter。它是对读取文件操作系统的封装，所有的读写都是直接操作文件系统。因此如果是频繁读写操作，不建议使用FileReader 和 FileWriter，性能将会非常低，这时需要使用BufferedReader。</p>
<p>BufferedReader和BufferedWriter类各拥有8192字符的缓冲区。当BufferedReader在读取文本文件时，会先尽量从文件中读入字符数据并置入缓冲区，而之后若使用read()方法，会先从缓冲区中进行读取。如果缓冲区数据不足，才会再从文件中读取，使用BufferedWriter时，写入的数据并不会先输出到目的地，而是先存储至缓冲区中。如果缓冲区中的数据满了，才会一次对目的地进行写出。</p>
<p>从标准输入流System.in中直接读取使用者输入时，使用者每输入一个字符，System.in就读取一个字符。为了能一次读取一行使用者的输入，使用了BufferedReader来对使用者输入的字符进行缓冲。readLine()方法会在读取到使用者的换行字符时，再一次将整行字符串传入</p>
<h1 id="深拷贝、浅拷贝、引用拷贝"><a href="#深拷贝、浅拷贝、引用拷贝" class="headerlink" title="深拷贝、浅拷贝、引用拷贝"></a>深拷贝、浅拷贝、引用拷贝</h1><p>拷贝分为两大类：引用拷贝与对象拷贝，深拷贝与浅拷贝属于对象拷贝，引用拷贝仅操作栈，深浅拷贝堆栈都有</p>
<ul>
<li>引用拷贝<br>对引用地址的拷贝，说明引用地址一样，指向堆中的对象也是同一个对象。如果对一个对象进行改变，其他对象也会跟着改变。</li>
<li>对象拷贝<br>指 对某一对象进行拷贝，是创建了一个全新的对象，也就是内存中存在二个不同地址的对象，这二个对象的基本数据类型变量的内容值都是一样的，但所包含的对象变量的地址可能一样可能不一样，浅拷贝与深拷贝的区别就在这里。</li>
</ul>
<p>浅拷贝：</p>
<p>当前对象里包含有对象变量，如果复制的对象中的对象变量和原对象里的对象地址值是相同的，即引用拷贝，则称之为浅拷贝。我们也可以称之为部分拷贝，即拷贝的不彻底。</p>
<p>深拷贝：</p>
<p>当前对象里包含有对象变量，如果复制的对象中的对象变量和原对象里的对象地址值是不同的，即创建了一个新的对象，则称之为深拷贝。我们也可以称之为完全拷贝，内部进行了彻底拷贝。</p>
<p><img src="https://raw.githubusercontent.com/zodical416/picto/master/1663493293512.png"></p>
<h1 id="异常与错误"><a href="#异常与错误" class="headerlink" title="异常与错误"></a>异常与错误</h1><p>在 Java 中，所有的异常都有一个共同的祖先就是 java.lang 包中的 Throwable 类，Throwable 类中有两个重要的子类 Exception 与 Error。异常与错误的最基本区别就是，异常能够被程序本身处理，而错误是无法被处理的，只能尽量来避免</p>
<ul>
<li>异常：程序本身能够处理的异常，可以通过 catch 来捕获，异常又可分为 受检查异常(必须处理) 和不受检查异常(可以不进行处理)</li>
<li>错误：属于程序无法处理的错误，无法通过 catch 来捕获，常见的错误有：Java 虚拟机运行错误、虚拟机内存不够错误、类定义错误等，这些错误发生时，JVM 一般会选择线程终止</li>
</ul>
<p>出现Error错误一般不是由于编写的代码出现问题，而是由于JVM运行这段代码出现了问题，比如堆溢出，配置文件出错等，这些你是无法人为的在你代码里可以保证的，必须要额外的去操作，重新配置虚拟机，修改配置文件等等。</p>
<h2 id="受检查异常"><a href="#受检查异常" class="headerlink" title="受检查异常"></a>受检查异常</h2><p>编译器要求必须处置的异常，也就是对于某段代码，编译器要求必须对这段代码加 try……catch 或者 throws Exception。在代码还未运行时，编译器就会检查该代码，判断其是否会出现异常，从而要求对可能出现的异常做出必须的处理。</p>
<p>处理方式：</p>
<ul>
<li>抛出，消极的处理方法，一直将其抛出到 Java 虚拟机进行处理</li>
<li>捕获：采用 try……catch 进行捕获</li>
</ul>
<p>那么如何区分哪些异常是受检查异常呢，实际上，除了 RuntimeException 及其子类，以及错误，其他异常都是受检查异常</p>
<h2 id="不受检查异常"><a href="#不受检查异常" class="headerlink" title="不受检查异常"></a>不受检查异常</h2><p>编译器不要求强制处置的异常，虽然有可能会出错，但是不会在编译时进行检查，例如 NullPointerException、IndexOutOfBoundsException、VirtualMachineError 等，又称为运行时异常</p>
<p>处理方式：捕获、继续抛出、不处理，通常采用不处理方式</p>
<h2 id="try-catch-finally"><a href="#try-catch-finally" class="headerlink" title="try-catch-finally"></a>try-catch-finally</h2><ul>
<li>try 块：用于捕获异常，可以接零个或多个 catch 块，如果没有 catch 块，必须跟一个 finally 块</li>
<li>catch 块：用于处理异常</li>
<li>finally：无论是否捕获或处理异常，finally 块内的语句都会被执行。当在 try 或者 catch 块中遇到 return 语句时，finally 块将会在方法返回之前执行</li>
</ul>
<p>在以下三种特殊情况下，finally 块不会被执行：</p>
<ul>
<li>在 try 或 finally 块中用了 System.exit(int) 退出程序。不过如果该语句是在异常语句之后，那么 finally 依然会执行</li>
<li>程序所在线程死亡</li>
<li>关闭 CPU</li>
</ul>
<h3 id="JAVA中try、catch、finally带return的执行顺序"><a href="#JAVA中try、catch、finally带return的执行顺序" class="headerlink" title="JAVA中try、catch、finally带return的执行顺序"></a>JAVA中try、catch、finally带return的执行顺序</h3><p>当 try 中带有 return 时，会先执行 return 前的代码，之后暂时保存需要 return 的信息，再执行 finally 中的代码，最后再通过 return 返回之前保存的信息。</p>
<p>当 catch 中带有 return 时，会先执行return前的代码，然后暂时保存需要return的信息，再执行finally中的代码，最后再通过return返回之前保存的信息。</p>
<p>当 try、catch、finally 中都带有 return 时 / finally 中带有 return 时，try 与 catch 中的 return 会失效，在执行完 finally 中的 return 后，不会再执行 try 中的 return。这种写法编译会给予警告。</p>
<h2 id="什么时候用-try-catch"><a href="#什么时候用-try-catch" class="headerlink" title="什么时候用 try-catch"></a>什么时候用 try-catch</h2><p>如果明确知道如何处理异常，比如在捕获异常后进行回滚操作、重试机制等，可以使用 try-catch 进行操作；如果不清楚当前异常如何进行处理，就需要 throws 抛出，把异常交给调用层处理。如果要try的代码块，与后续要执行的代码逻辑是解耦的(即该部分调用是否有异常跟后面要运行的代码逻辑没有关系)，为了避免该部分因为运行异常导致的程序crash退出，可将该部分进行try…catch</p>
<p>如果在最外层函数上，那么就需要使用 try-catch，因为此时函数无法再继续往外抛出异常了，因此需要进行 catch 来做进一步的处理</p>
<h1 id="Java-8-新特性：Lambda-表达式与-Stream"><a href="#Java-8-新特性：Lambda-表达式与-Stream" class="headerlink" title="Java 8 新特性：Lambda 表达式与 Stream"></a>Java 8 新特性：Lambda 表达式与 Stream</h1><h2 id="Lambda-表达式"><a href="#Lambda-表达式" class="headerlink" title="Lambda 表达式"></a>Lambda 表达式</h2><p>也称之为闭包，其本质是一个匿名函数（没有名称且不属于任何类的函数）。采用 Lambda 函数之后，能够简化函数式接口的使用，也就是对于只有一个抽象方法的普通接口，可以用 Lambda 表达式来简化代码的编写</p>
<p>使用 Lambda 表达式的主要优点就是能够简化代码，减少类文件的产生，能够将功能作为参数向下传递。缺点就是影响了代码的可读性。</p>
<h2 id="Stream"><a href="#Stream" class="headerlink" title="Stream"></a>Stream</h2><p>Stream 能够用来处理集合，通过使用Stream API 对集合数据进行操作，能够非常高效地处理数据。</p>
<p>一些常用的 api：</p>
<p>filter：过滤流中的某些元素(可以做一些基本的判空、替换、判断逻辑操作)</p>
<p>limit(n)：获取n个元素，结果获取几个元素</p>
<p>skip(n)：跳过n元素，配合limit(n)可实现分页</p>
<p>distinct：通过流中元素的 hashCode() 和 equals() 去除重复元素</p>
<h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>新 interface 的方法可以用<code>default</code> 或 <code>static</code>修饰，这样就可以有方法体，实现类也不必重写此方法。</p>
<p>Java8 中接口可以有自己的方法实现，那么接口与抽象类还有什么区别呢？</p>
<ol>
<li>interface 和 class 的区别，好像是废话，主要有：<ul>
<li>接口多实现，类单继承</li>
<li>接口的方法是 public abstract 修饰，变量是 public static final 修饰。 abstract class 可以用其他修饰符</li>
</ul>
</li>
<li>interface 的方法是更像是一个扩展插件。而 abstract class 的方法是要继承的。</li>
</ol>
<p>开始我们也提到，interface 新增<code>default</code>和<code>static</code>修饰的方法，为了解决接口的修改与现有的实现不兼容的问题，并不是为了要替代<code>abstract class</code>。在使用上，该用 abstract class 的地方还是要用 abstract class，不要因为 interface 的新特性而将之替换。</p>
<h1 id="Autowired-和-Resource-区别对比"><a href="#Autowired-和-Resource-区别对比" class="headerlink" title="Autowired 和 Resource 区别对比"></a>Autowired 和 Resource 区别对比</h1><p>@Autowired 和 @Resource 都是做 bean 的注入时使用，两者都可以写在字段和 setter 方法上，如果都写在字段上，那么就不需要再写 setter 方法</p>
<p>Autowired 与 Resource 的主要区别在于，Autowired按 byType 自动注入，Resource 按 byName 自动注入</p>
<h1 id="Java-序列化"><a href="#Java-序列化" class="headerlink" title="Java 序列化"></a>Java 序列化</h1><p>目的是将一个 Java 对象转变为二进制流，从而持久化保存在硬盘中，避免程序运行结束后对象就从内存中消失。</p>
<ul>
<li>序列化：将 Java 对象转换为字节序列</li>
<li>反序列化： 把字节序列恢复为原来的 Java 对象</li>
</ul>
<h2 id="对象序列化的方法"><a href="#对象序列化的方法" class="headerlink" title="对象序列化的方法"></a>对象序列化的方法</h2><p>在 Java 中，如果一个对象要想实现序列化，必须实现 Serializable 接口与 Externalizable 接口的其中之一</p>
<h3 id="Serializable-接口"><a href="#Serializable-接口" class="headerlink" title="Serializable 接口"></a>Serializable 接口</h3><p>一个对象想要被序列化，那么它的类就要实现此接口或者它的子接口。这个对象的所有属性(包括 private 属性、引用的对象等)都可以被序列化和反序列化来保存，不想序列化的字段可以使用 transient 来修饰。</p>
<ul>
<li>transient 只能修饰变量，不能修饰类和方法</li>
<li>transient 修饰的变量，在反序列化后变量值会被置为类型的默认值，例如 int 类型反序列化后变为 0</li>
<li>static 变量不属于任何对象，因此无论有没有 transient 修饰，都不会被序列化</li>
</ul>
<h3 id="Externalizable-接口"><a href="#Externalizable-接口" class="headerlink" title="Externalizable 接口"></a>Externalizable 接口</h3><p>是 Serializable 接口的子类，通过 writeExternal() 和 readExternal() 方法，决定如何序列化和反序列化。序列化和反序列化方法需要自己实现，因此可以指定序列化哪些属性，transient 在这里是无效的</p>
<h1 id="Java-中终止线程的方法"><a href="#Java-中终止线程的方法" class="headerlink" title="Java 中终止线程的方法"></a>Java 中终止线程的方法</h1><ul>
<li>设置退出标志，使线程正常退出，也就是当 run() 方法完成后线程终止</li>
<li>使用 interrupt() 方法中断线程</li>
<li>使用 stop() 方法强行终止线程，但是该方法过于暴力，会强行将执行一半的线程终止，不会保证线程资源的正确释放。</li>
</ul>
<h2 id="使用退出标志终止线程"><a href="#使用退出标志终止线程" class="headerlink" title="使用退出标志终止线程"></a>使用退出标志终止线程</h2><p>一般 run() 方法执行完，线程就会正常结束。然而，有些线程是伺服线程，需要长时间的运行，只有在外部某些条件满足的情况下，才能关闭这些线程。因此可以设置一个标志位来控制线程运行的循环，并使用 volatile 关键字对其进行修饰，从而确保同一时刻仅有一个线程来修改标志位的值</p>
<h2 id="使用-interrupt-方法中断当前线程"><a href="#使用-interrupt-方法中断当前线程" class="headerlink" title="使用 interrupt() 方法中断当前线程"></a>使用 interrupt() 方法中断当前线程</h2><p>使用该方法中断线程有两种情况：</p>
<ol>
<li>线程处于阻塞状态，如果使用了 sleep、wait 等方法，线程会处于阻塞状态，当调用线程的 interrupt 方法时，会抛出异常。需要先对该异常进行捕获，之后通过 break 来跳出循环，这样才能正常结束 run 方法</li>
<li>线程处于未阻塞状态，使用 isInterrupted() 判断线程的中断标志来退出循环。当使用 interrupt() 方法时，中断标志就会置为 true，和利用自定义的标志来控制循环相似</li>
</ol>
<p>为什么要分成阻塞与非阻塞两种状态，主要区别就在于当处于阻塞状态时，如果发生 interrupt()，系统除了会抛出异常外，还会调用 interrupted() 函数，调用时能获取到中断状态为 true 的状态，调用结束后会复位中断状态为 false，所以异常抛出后通过 isInterrupted() 是获取不到中断状态为 true 的状态，从而无法退出循环。</p>
<h2 id="使用-stop-方法终止线程"><a href="#使用-stop-方法终止线程" class="headerlink" title="使用 stop 方法终止线程"></a>使用 stop 方法终止线程</h2><p>也可以在程序中直接调用 thread.stop() 来强行终止线程，但是该方法不安全，并会破坏数据的一致性，造成错误，因此不推荐用 stop 方法终止线程</p>
<h1 id="Object-类中的方法"><a href="#Object-类中的方法" class="headerlink" title="Object 类中的方法"></a>Object 类中的方法</h1><p>Object 类是所有类的父类，其位于 java.lang 包中，编译会自动导入。创建一个类时如果没有明确继承一个父类，那么会自动继承 Object</p>
<p>Object 类中包含的方法有 Object()、getClass()、hashCode()、equals()、clone()、toString()、notify()、notifyAll()、wait(long)、wait(long,int)、wait()、finalize()共十二个方法</p>
<p>对这些方法的简单介绍：</p>
<p>Object() 是默认构造方法，clone 是创建并返回对象的一个副本，equals 是判断是否相等，finalize 是当垃圾回收器确定不存在对该对象的更多引用时，由垃圾回收器调用此方法，getClass 返回一个对象的运行时类，hashCode 返回对象的哈希值，notify 唤醒该对象监视器上等待的单个线程，notifyAll 唤醒所有线程，toString 返回对象的字符串表示，wait 使当前线程等待，wait(long timeout) 导致当前的线程等待调用此对象的notify()或notifyAll()，wait(long timeout, int nanos)：导致当前的线程等待，直到其他线程调用此对象的notify()或notifyAll()，或其他某个线程中断当前线程，或者已超过某个实际时间量</p>
<h1 id="代码结构"><a href="#代码结构" class="headerlink" title="代码结构"></a>代码结构</h1><h2 id="Model"><a href="#Model" class="headerlink" title="Model"></a>Model</h2><p>模型，常常与持久化数据相互对应，如 MySQL 和 MongoDB 等。Model 承载的是数据的抽象，描述了一个数据的定义，Model 实例就是一组组的数据，Model 应该是一个纯数据的集合。</p>
<h2 id="Util"><a href="#Util" class="headerlink" title="Util"></a>Util</h2><p>工具，常常用来描述与业务逻辑没有关系的数据处理。一般与私有方法进行对比，私有方法越多往往代码越乱，因此常见的重构逻辑就是从代码中抽象出若干个私有方法，最后再抽象出公用的 util</p>
<p>如果可能，应该尽可能少用私有方法，而是将其转换为一个公用的 util，代表其与业务逻辑是不相干的。</p>
<h2 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h2><p>服务，可能包含一系列的数据处理，也可能调用多个 util 或其他的服务。如果说 util 是工具，那么 Service 就是操作工具的人</p>
<h2 id="Dao"><a href="#Dao" class="headerlink" title="Dao"></a>Dao</h2><p>与底层数据库通信，负责数据库的增删改查 CRUD。最佳实践是一个 Service 对应一个 Dao</p>
<h2 id="Controller"><a href="#Controller" class="headerlink" title="Controller"></a>Controller</h2><p>控制中心，所有指令、调度都从此处发出。具体每个 Service 做什么事、谁的数据提供给谁，都是在 Controller 实现的。</p>
<h1 id="类的设计原则"><a href="#类的设计原则" class="headerlink" title="类的设计原则"></a>类的设计原则</h1><h2 id="开闭原则"><a href="#开闭原则" class="headerlink" title="开闭原则"></a>开闭原则</h2><p>对扩展开放，对修改关闭。也就是说在实现一个新功能时，首先想的应该是扩展原有功能，而不是修改之前的功能。</p>
<h2 id="里氏代换原则"><a href="#里氏代换原则" class="headerlink" title="里氏代换原则"></a>里氏代换原则</h2><p>面向对象设计的基本原则之一，指的是子类必须能够替换其基类。该原则是继承复用的基石，只有当子类能够替换基类，并且软件功能不受影响时，基类才能够被真正复用，子类也能够在基类基础上增加新的行为。</p>
<h2 id="依赖倒转原则"><a href="#依赖倒转原则" class="headerlink" title="依赖倒转原则"></a>依赖倒转原则</h2><p>开闭原则的基础，具体指的是针对接口编程，依赖于抽象而不依赖于具体</p>
<h2 id="接口隔离原则"><a href="#接口隔离原则" class="headerlink" title="接口隔离原则"></a>接口隔离原则</h2><p>使用多个隔离的接口，比使用单个接口要好，是基于高内聚、低耦合的思想实现的。</p>
<h2 id="迪米特法则，即最少知道原则"><a href="#迪米特法则，即最少知道原则" class="headerlink" title="迪米特法则，即最少知道原则"></a>迪米特法则，即最少知道原则</h2><p>一个实体应当尽量少地与其他实体之间发生相互作用，使得系统功能模块相对独立</p>
<h2 id="合成复用原则"><a href="#合成复用原则" class="headerlink" title="合成复用原则"></a>合成复用原则</h2><p>尽量使用合成/聚合的方式，而不是使用继承</p>
<h1 id="Static-关键字"><a href="#Static-关键字" class="headerlink" title="Static 关键字"></a>Static 关键字</h1><p>用于修饰类的方法与成员变量</p>
<h2 id="Static-方法"><a href="#Static-方法" class="headerlink" title="Static 方法"></a>Static 方法</h2><p>static方法一般称作静态方法，由于静态方法不依赖于任何对象就可以进行访问，因此对于静态方法来说，是没有this的，因为它不依附于任何对象，既然都没有对象，就谈不上this了。并且由于这个特性，在静态方法中不能访问类的非静态成员变量和非静态成员方法，因为非静态成员方法/变量都是必须依赖具体的对象才能够被调用。</p>
<h2 id="Static-变量"><a href="#Static-变量" class="headerlink" title="Static 变量"></a>Static 变量</h2><p>static变量也称作静态变量，静态变量和非静态变量的区别是：静态变量被所有的对象所共享，在内存中只有一个副本，它当且仅当在类初次加载时会被初始化。而非静态变量是对象所拥有的，在创建对象的时候被初始化，存在多个副本，各个对象拥有的副本互不影响。</p>
<p>static成员变量的初始化顺序按照定义的顺序进行初始化。</p>
<h2 id="Static-代码块"><a href="#Static-代码块" class="headerlink" title="Static 代码块"></a>Static 代码块</h2><p>static关键字还有一个比较关键的作用就是 用来形成静态代码块以优化程序性能。static块可以置于类中的任何地方，类中可以有多个static块。在类初次被加载的时候，会按照static块的顺序来执行每个static块，并且只会执行一次。</p>
<h1 id="final-关键字"><a href="#final-关键字" class="headerlink" title="final 关键字"></a>final 关键字</h1><p>final关键字可以用来修饰类、方法和变量</p>
<h2 id="修饰类"><a href="#修饰类" class="headerlink" title="修饰类"></a>修饰类</h2><p>当用final修饰一个类时，表明这个类不能被继承。也就是说，如果一个类你永远不会让他被继承，就可以用final进行修饰。final类中的成员变量可以根据需要设为final，但是要注意final类中的所有成员方法都会被隐式地指定为final方法。</p>
<h2 id="修饰方法"><a href="#修饰方法" class="headerlink" title="修饰方法"></a>修饰方法</h2><p>被 final 修饰的方法不能被重写，类的private方法会隐式地被指定为final方法。</p>
<h2 id="修饰变量"><a href="#修饰变量" class="headerlink" title="修饰变量"></a>修饰变量</h2><p>对于一个final变量，如果是基本数据类型的变量，则其数值一旦在初始化之后便不能更改；如果是引用类型的变量，则在对其初始化之后便不能再让其指向另一个对象。</p>

      
      <div>
    
        <div style="text-align:center;color: #ccc;font-size:14px;">-------------本文结束<i class="fa fa-paw"></i>感谢您的阅读-------------</div>
    
</div>
      
    </div>


    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Java-%E5%9F%BA%E7%A1%80/" rel="tag"># Java 基础</a>
              <a href="/tags/%E9%9D%A2%E8%AF%95/" rel="tag"># 面试</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2022/08/15/Nginx%20%E5%9F%BA%E7%A1%80/" rel="prev" title="Nginx 基础">
      <i class="fa fa-chevron-left"></i> Nginx 基础
    </a></div>
      <div class="post-nav-item">
    <a href="/2022/08/15/Linux/" rel="next" title="Linux 基础">
      Linux 基础 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="nav-number">1.</span> <span class="nav-text">基本数据类型</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%92%8C-equals-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">2.</span> <span class="nav-text">&#x3D;&#x3D; 和 equals 的区别</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%87%8D%E5%86%99-equals-%E6%97%B6%E5%BF%85%E9%A1%BB%E9%87%8D%E5%86%99-hashCode-%E6%96%B9%E6%B3%95%EF%BC%9F"><span class="nav-number">3.</span> <span class="nav-text">为什么重写 equals() 时必须重写 hashCode() 方法？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F%E4%B8%8E%E9%9D%9E%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F%EF%BC%88%E5%BD%92%E5%B1%9E%E3%80%81%E5%AD%98%E5%82%A8%E3%80%81%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E3%80%81%E8%AE%BF%E9%97%AE%E6%96%B9%E5%BC%8F%EF%BC%89"><span class="nav-number">4.</span> <span class="nav-text">静态变量与非静态变量（归属、存储、生命周期、访问方式）</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#static-%E5%85%B3%E9%94%AE%E5%AD%97"><span class="nav-number">5.</span> <span class="nav-text">static 关键字</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#static-%E6%96%B9%E6%B3%95"><span class="nav-number">5.1.</span> <span class="nav-text">static 方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#static-%E5%8F%98%E9%87%8F"><span class="nav-number">5.2.</span> <span class="nav-text">static 变量</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#static-%E4%BB%A3%E7%A0%81%E5%9D%97"><span class="nav-number">5.3.</span> <span class="nav-text">static 代码块</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Java-%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7"><span class="nav-number">6.</span> <span class="nav-text">Java 三大特性</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%9A%E6%80%81"><span class="nav-number">6.1.</span> <span class="nav-text">多态</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B0%81%E8%A3%85"><span class="nav-number">6.2.</span> <span class="nav-text">封装</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%A7%E6%89%BF"><span class="nav-number">6.3.</span> <span class="nav-text">继承</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%AD%90%E7%B1%BB%E4%B8%8D%E8%83%BD%E9%87%8D%E5%86%99%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%EF%BC%8C%E4%BD%86%E6%98%AF%E6%9E%84%E9%80%A0%E6%96%B9%E8%83%BD%E5%8F%AF%E4%BB%A5%E8%A2%AB%E9%87%8D%E8%BD%BD"><span class="nav-number">7.</span> <span class="nav-text">子类不能重写构造方法，但是构造方能可以被重载</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%87%8D%E5%86%99%E4%B8%8E%E9%87%8D%E8%BD%BD%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">8.</span> <span class="nav-text">重写与重载的区别</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%87%8D%E5%86%99%E8%A7%84%E5%88%99"><span class="nav-number">8.1.</span> <span class="nav-text">重写规则</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%87%8D%E8%BD%BD%E8%A7%84%E5%88%99"><span class="nav-number">8.2.</span> <span class="nav-text">重载规则</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Java-%E4%B8%AD%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%96%B9%E6%B3%95"><span class="nav-number">9.</span> <span class="nav-text">Java 中创建对象的方法</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%80%BC%E4%BC%A0%E9%80%92%EF%BC%9AJava-%E4%B8%AD%E6%B2%A1%E6%9C%89%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92"><span class="nav-number">10.</span> <span class="nav-text">值传递：Java 中没有引用传递</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#String-%E5%92%8C-StringBuffer-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%8C%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E6%97%B6%E4%BD%BF%E7%94%A8-String-%E8%B5%8B%E5%80%BC%E5%92%8C%E7%94%A8-new-%E5%88%9B%E5%BB%BA%E6%98%AF%E5%90%A6%E4%B8%80%E6%A0%B7%EF%BC%9F"><span class="nav-number">11.</span> <span class="nav-text">String 和 StringBuffer 的区别，创建对象时使用 String 赋值和用 new 创建是否一样？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="nav-number">12.</span> <span class="nav-text">修饰符</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%8E%A5%E5%8F%A3%E5%92%8C%E6%8A%BD%E8%B1%A1%E7%B1%BB"><span class="nav-number">13.</span> <span class="nav-text">接口和抽象类</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8C%BA%E5%88%AB%E4%B8%8E%E5%85%B1%E5%90%8C%E7%82%B9"><span class="nav-number">13.1.</span> <span class="nav-text">区别与共同点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E7%94%A8%E6%8A%BD%E8%B1%A1%E7%B1%BB%EF%BC%8C%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E7%94%A8%E6%8E%A5%E5%8F%A3"><span class="nav-number">13.2.</span> <span class="nav-text">什么时候用抽象类，什么时候用接口</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB%E8%83%BD%E7%94%A8-final-%E4%BF%AE%E9%A5%B0%E5%90%97"><span class="nav-number">13.3.</span> <span class="nav-text">抽象类能用 final 修饰吗</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB%E4%B8%AD%E5%8F%AF%E4%B8%8D%E5%8F%AF%E4%BB%A5%E6%9C%89-private-%E5%8F%98%E9%87%8F%E4%B8%8E%E6%96%B9%E6%B3%95"><span class="nav-number">13.4.</span> <span class="nav-text">抽象类中可不可以有 private 变量与方法</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8F%8D%E5%B0%84"><span class="nav-number">14.</span> <span class="nav-text">反射</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%94%A8%E6%B3%95"><span class="nav-number">14.1.</span> <span class="nav-text">用法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%94%A8%E9%80%94"><span class="nav-number">14.2.</span> <span class="nav-text">用途</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%90%E7%94%A8"><span class="nav-number">14.3.</span> <span class="nav-text">运用</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%AD%BB%E9%94%81"><span class="nav-number">15.</span> <span class="nav-text">死锁</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%A7%E7%94%9F%E6%AD%BB%E9%94%81%E7%9A%84%E5%9B%9B%E4%B8%AA%E6%9D%A1%E4%BB%B6"><span class="nav-number">15.1.</span> <span class="nav-text">产生死锁的四个条件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E6%AD%BB%E9%94%81%EF%BC%9F"><span class="nav-number">15.2.</span> <span class="nav-text">如何解决死锁？</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A0%B4%E5%9D%8F%E8%AF%B7%E6%B1%82%E4%B8%8E%E4%BF%9D%E6%8C%81%E6%9D%A1%E4%BB%B6"><span class="nav-number">15.2.1.</span> <span class="nav-text">破坏请求与保持条件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A0%B4%E5%9D%8F%E4%B8%8D%E5%89%A5%E5%A4%BA%E6%9D%A1%E4%BB%B6"><span class="nav-number">15.2.2.</span> <span class="nav-text">破坏不剥夺条件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A0%B4%E5%9D%8F%E5%BE%AA%E7%8E%AF%E7%AD%89%E5%BE%85%E6%9D%A1%E4%BB%B6"><span class="nav-number">15.2.3.</span> <span class="nav-text">破坏循环等待条件</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%93%B6%E8%A1%8C%E5%AE%B6%E7%AE%97%E6%B3%95"><span class="nav-number">15.3.</span> <span class="nav-text">银行家算法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%AD%BB%E9%94%81%E7%9A%84%E4%BB%A3%E7%A0%81"><span class="nav-number">15.4.</span> <span class="nav-text">死锁的代码</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Java-%E4%B8%AD%E8%87%AA%E5%B8%A6%E7%9A%84%E6%B3%A8%E8%A7%A3"><span class="nav-number">16.</span> <span class="nav-text">Java 中自带的注解</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8B%BC%E6%8E%A5%EF%BC%9AStringBuilder-%E5%8F%8A%E5%85%B6%E4%BB%96"><span class="nav-number">17.</span> <span class="nav-text">字符串拼接：StringBuilder 及其他</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Java-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="nav-number">18.</span> <span class="nav-text">Java 基本数据类型</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Java-IO-%E6%B5%81%EF%BC%88%E5%AD%97%E7%AC%A6%E6%B5%81%E3%80%81%E5%AD%97%E8%8A%82%E6%B5%81%EF%BC%88%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%B5%81%EF%BC%89%EF%BC%89"><span class="nav-number">19.</span> <span class="nav-text">Java IO 流（字符流、字节流（二进制流））</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AD%97%E8%8A%82%E6%B5%81"><span class="nav-number">19.1.</span> <span class="nav-text">字节流</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E6%B5%81"><span class="nav-number">19.2.</span> <span class="nav-text">字符流</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%B7%B1%E6%8B%B7%E8%B4%9D%E3%80%81%E6%B5%85%E6%8B%B7%E8%B4%9D%E3%80%81%E5%BC%95%E7%94%A8%E6%8B%B7%E8%B4%9D"><span class="nav-number">20.</span> <span class="nav-text">深拷贝、浅拷贝、引用拷贝</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%BC%82%E5%B8%B8%E4%B8%8E%E9%94%99%E8%AF%AF"><span class="nav-number">21.</span> <span class="nav-text">异常与错误</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%97%E6%A3%80%E6%9F%A5%E5%BC%82%E5%B8%B8"><span class="nav-number">21.1.</span> <span class="nav-text">受检查异常</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%8D%E5%8F%97%E6%A3%80%E6%9F%A5%E5%BC%82%E5%B8%B8"><span class="nav-number">21.2.</span> <span class="nav-text">不受检查异常</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#try-catch-finally"><span class="nav-number">21.3.</span> <span class="nav-text">try-catch-finally</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#JAVA%E4%B8%ADtry%E3%80%81catch%E3%80%81finally%E5%B8%A6return%E7%9A%84%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F"><span class="nav-number">21.3.1.</span> <span class="nav-text">JAVA中try、catch、finally带return的执行顺序</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E7%94%A8-try-catch"><span class="nav-number">21.4.</span> <span class="nav-text">什么时候用 try-catch</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Java-8-%E6%96%B0%E7%89%B9%E6%80%A7%EF%BC%9ALambda-%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%B8%8E-Stream"><span class="nav-number">22.</span> <span class="nav-text">Java 8 新特性：Lambda 表达式与 Stream</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Lambda-%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-number">22.1.</span> <span class="nav-text">Lambda 表达式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Stream"><span class="nav-number">22.2.</span> <span class="nav-text">Stream</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8E%A5%E5%8F%A3"><span class="nav-number">22.3.</span> <span class="nav-text">接口</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Autowired-%E5%92%8C-Resource-%E5%8C%BA%E5%88%AB%E5%AF%B9%E6%AF%94"><span class="nav-number">23.</span> <span class="nav-text">Autowired 和 Resource 区别对比</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Java-%E5%BA%8F%E5%88%97%E5%8C%96"><span class="nav-number">24.</span> <span class="nav-text">Java 序列化</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E5%BA%8F%E5%88%97%E5%8C%96%E7%9A%84%E6%96%B9%E6%B3%95"><span class="nav-number">24.1.</span> <span class="nav-text">对象序列化的方法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Serializable-%E6%8E%A5%E5%8F%A3"><span class="nav-number">24.1.1.</span> <span class="nav-text">Serializable 接口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Externalizable-%E6%8E%A5%E5%8F%A3"><span class="nav-number">24.1.2.</span> <span class="nav-text">Externalizable 接口</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Java-%E4%B8%AD%E7%BB%88%E6%AD%A2%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%96%B9%E6%B3%95"><span class="nav-number">25.</span> <span class="nav-text">Java 中终止线程的方法</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E9%80%80%E5%87%BA%E6%A0%87%E5%BF%97%E7%BB%88%E6%AD%A2%E7%BA%BF%E7%A8%8B"><span class="nav-number">25.1.</span> <span class="nav-text">使用退出标志终止线程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-interrupt-%E6%96%B9%E6%B3%95%E4%B8%AD%E6%96%AD%E5%BD%93%E5%89%8D%E7%BA%BF%E7%A8%8B"><span class="nav-number">25.2.</span> <span class="nav-text">使用 interrupt() 方法中断当前线程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-stop-%E6%96%B9%E6%B3%95%E7%BB%88%E6%AD%A2%E7%BA%BF%E7%A8%8B"><span class="nav-number">25.3.</span> <span class="nav-text">使用 stop 方法终止线程</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Object-%E7%B1%BB%E4%B8%AD%E7%9A%84%E6%96%B9%E6%B3%95"><span class="nav-number">26.</span> <span class="nav-text">Object 类中的方法</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E7%BB%93%E6%9E%84"><span class="nav-number">27.</span> <span class="nav-text">代码结构</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Model"><span class="nav-number">27.1.</span> <span class="nav-text">Model</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Util"><span class="nav-number">27.2.</span> <span class="nav-text">Util</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Service"><span class="nav-number">27.3.</span> <span class="nav-text">Service</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Dao"><span class="nav-number">27.4.</span> <span class="nav-text">Dao</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Controller"><span class="nav-number">27.5.</span> <span class="nav-text">Controller</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%B1%BB%E7%9A%84%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99"><span class="nav-number">28.</span> <span class="nav-text">类的设计原则</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BC%80%E9%97%AD%E5%8E%9F%E5%88%99"><span class="nav-number">28.1.</span> <span class="nav-text">开闭原则</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%87%8C%E6%B0%8F%E4%BB%A3%E6%8D%A2%E5%8E%9F%E5%88%99"><span class="nav-number">28.2.</span> <span class="nav-text">里氏代换原则</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BE%9D%E8%B5%96%E5%80%92%E8%BD%AC%E5%8E%9F%E5%88%99"><span class="nav-number">28.3.</span> <span class="nav-text">依赖倒转原则</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8E%A5%E5%8F%A3%E9%9A%94%E7%A6%BB%E5%8E%9F%E5%88%99"><span class="nav-number">28.4.</span> <span class="nav-text">接口隔离原则</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%AA%E7%B1%B3%E7%89%B9%E6%B3%95%E5%88%99%EF%BC%8C%E5%8D%B3%E6%9C%80%E5%B0%91%E7%9F%A5%E9%81%93%E5%8E%9F%E5%88%99"><span class="nav-number">28.5.</span> <span class="nav-text">迪米特法则，即最少知道原则</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%90%88%E6%88%90%E5%A4%8D%E7%94%A8%E5%8E%9F%E5%88%99"><span class="nav-number">28.6.</span> <span class="nav-text">合成复用原则</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Static-%E5%85%B3%E9%94%AE%E5%AD%97"><span class="nav-number">29.</span> <span class="nav-text">Static 关键字</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Static-%E6%96%B9%E6%B3%95"><span class="nav-number">29.1.</span> <span class="nav-text">Static 方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Static-%E5%8F%98%E9%87%8F"><span class="nav-number">29.2.</span> <span class="nav-text">Static 变量</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Static-%E4%BB%A3%E7%A0%81%E5%9D%97"><span class="nav-number">29.3.</span> <span class="nav-text">Static 代码块</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#final-%E5%85%B3%E9%94%AE%E5%AD%97"><span class="nav-number">30.</span> <span class="nav-text">final 关键字</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BF%AE%E9%A5%B0%E7%B1%BB"><span class="nav-number">30.1.</span> <span class="nav-text">修饰类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BF%AE%E9%A5%B0%E6%96%B9%E6%B3%95"><span class="nav-number">30.2.</span> <span class="nav-text">修饰方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BF%AE%E9%A5%B0%E5%8F%98%E9%87%8F"><span class="nav-number">30.3.</span> <span class="nav-text">修饰变量</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Zodiacal</p>
  <div class="site-description" itemprop="description">引出魔鬼的一种试炼</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">46</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">16</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">42</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Zodiacal</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">476k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">7:13</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
